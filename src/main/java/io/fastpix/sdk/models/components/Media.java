/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
package io.fastpix.sdk.models.components;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.core.type.TypeReference;
import io.fastpix.sdk.utils.LazySingletonValue;
import io.fastpix.sdk.utils.Utils;
import java.lang.Boolean;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.time.OffsetDateTime;
import java.util.List;
import java.util.Objects;
import java.util.Optional;

public class Media {

    /**
     * A video thumbnail is a still image that acts as the preview image for your video.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("thumbnail")
    private Optional<String> thumbnail;

    /**
     * When creating the media, FastPix assigns a universally unique identifier with a maximum length of 255 characters.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("id")
    private Optional<String> id;

    /**
     * A unique identifier is generated by FastPix for the workspace.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("workspaceId")
    private Optional<String> workspaceId;

    /**
     * You can search for videos with specific key value pairs using metadata, when you tag a video in "key" : "value" pairs. Dynamic Metadata allows you to define a key that allows any value pair. You can have maximum of 255 characters and upto 10 entries are allowed.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("metadata")
    private Optional<? extends MediaMetadata> metadata;

    /**
     * The maximum resolution specified by the user for the media.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("maxResolution")
    private Optional<? extends MediaMaxResolution> maxResolution;

    /**
     * The actual resolution of the uploaded media. This represents the native quality of the source media.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("sourceResolution")
    private Optional<? extends SourceResolution> sourceResolution;

    /**
     * Determines the media's status, which can be one of the possible values.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("status")
    private Optional<String> status;

    /**
     * Determines the type of MP4 support for the media.   - **none**: Disables MP4 support.   - **capped_4k**: Enables MP4 downloads with resolutions up to 4K.   - **audioOnly**: Provides an MP4 stream containing only the audio.   - **audioOnly,capped_4k**: Enables both MP4 video downloads (up to 4K) and an audio-only stream.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("mp4Support")
    private Optional<? extends MediaMp4Support> mp4Support;

    /**
     * The sourceAccess parameter determines whether the original media file is accessible. Set to true to enable access or false to restrict it
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("sourceAccess")
    private Optional<Boolean> sourceAccess;

    /**
     * A collection of Playback ID objects utilized for crafting HLS playback URLs.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("playbackIds")
    private Optional<? extends List<PlaybackId>> playbackIds;

    /**
     * A media consists of different media tracks, like video, audio, and subtitle, all combined.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("tracks")
    private Optional<? extends List<Track>> tracks;

    /**
     * The time span of the media, measured in seconds with a maximum allowable duration of 12 hours per individual media.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("duration")
    private Optional<String> duration;

    /**
     * Frame rate quantifies the speed at which frames are displayed per second. It represents the range of frames available for a specific track. If the frame rate of the input file is indeterminable, it will be indicated by a value of -1.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("frameRate")
    private Optional<String> frameRate;

    /**
     * The aspect ratio of a video is a value that describes the relative shape of a video based on its width and height.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("aspectRatio")
    private Optional<String> aspectRatio;

    /**
     * Time the media was created, defined as a localDateTime (UTC Time).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("createdAt")
    private Optional<OffsetDateTime> createdAt;

    /**
     * Time the media was updated, defined as a localDateTime (UTC Time).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("updatedAt")
    private Optional<OffsetDateTime> updatedAt;

    @JsonCreator
    public Media(
            @JsonProperty("thumbnail") Optional<String> thumbnail,
            @JsonProperty("id") Optional<String> id,
            @JsonProperty("workspaceId") Optional<String> workspaceId,
            @JsonProperty("metadata") Optional<? extends MediaMetadata> metadata,
            @JsonProperty("maxResolution") Optional<? extends MediaMaxResolution> maxResolution,
            @JsonProperty("sourceResolution") Optional<? extends SourceResolution> sourceResolution,
            @JsonProperty("status") Optional<String> status,
            @JsonProperty("mp4Support") Optional<? extends MediaMp4Support> mp4Support,
            @JsonProperty("sourceAccess") Optional<Boolean> sourceAccess,
            @JsonProperty("playbackIds") Optional<? extends List<PlaybackId>> playbackIds,
            @JsonProperty("tracks") Optional<? extends List<Track>> tracks,
            @JsonProperty("duration") Optional<String> duration,
            @JsonProperty("frameRate") Optional<String> frameRate,
            @JsonProperty("aspectRatio") Optional<String> aspectRatio,
            @JsonProperty("createdAt") Optional<OffsetDateTime> createdAt,
            @JsonProperty("updatedAt") Optional<OffsetDateTime> updatedAt) {
        Utils.checkNotNull(thumbnail, "thumbnail");
        Utils.checkNotNull(id, "id");
        Utils.checkNotNull(workspaceId, "workspaceId");
        Utils.checkNotNull(metadata, "metadata");
        Utils.checkNotNull(maxResolution, "maxResolution");
        Utils.checkNotNull(sourceResolution, "sourceResolution");
        Utils.checkNotNull(status, "status");
        Utils.checkNotNull(mp4Support, "mp4Support");
        Utils.checkNotNull(sourceAccess, "sourceAccess");
        Utils.checkNotNull(playbackIds, "playbackIds");
        Utils.checkNotNull(tracks, "tracks");
        Utils.checkNotNull(duration, "duration");
        Utils.checkNotNull(frameRate, "frameRate");
        Utils.checkNotNull(aspectRatio, "aspectRatio");
        Utils.checkNotNull(createdAt, "createdAt");
        Utils.checkNotNull(updatedAt, "updatedAt");
        this.thumbnail = thumbnail;
        this.id = id;
        this.workspaceId = workspaceId;
        this.metadata = metadata;
        this.maxResolution = maxResolution;
        this.sourceResolution = sourceResolution;
        this.status = status;
        this.mp4Support = mp4Support;
        this.sourceAccess = sourceAccess;
        this.playbackIds = playbackIds;
        this.tracks = tracks;
        this.duration = duration;
        this.frameRate = frameRate;
        this.aspectRatio = aspectRatio;
        this.createdAt = createdAt;
        this.updatedAt = updatedAt;
    }
    
    public Media() {
        this(Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty());
    }

    /**
     * A video thumbnail is a still image that acts as the preview image for your video.
     */
    @JsonIgnore
    public Optional<String> thumbnail() {
        return thumbnail;
    }

    /**
     * When creating the media, FastPix assigns a universally unique identifier with a maximum length of 255 characters.
     */
    @JsonIgnore
    public Optional<String> id() {
        return id;
    }

    /**
     * A unique identifier is generated by FastPix for the workspace.
     */
    @JsonIgnore
    public Optional<String> workspaceId() {
        return workspaceId;
    }

    /**
     * You can search for videos with specific key value pairs using metadata, when you tag a video in "key" : "value" pairs. Dynamic Metadata allows you to define a key that allows any value pair. You can have maximum of 255 characters and upto 10 entries are allowed.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<MediaMetadata> metadata() {
        return (Optional<MediaMetadata>) metadata;
    }

    /**
     * The maximum resolution specified by the user for the media.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<MediaMaxResolution> maxResolution() {
        return (Optional<MediaMaxResolution>) maxResolution;
    }

    /**
     * The actual resolution of the uploaded media. This represents the native quality of the source media.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<SourceResolution> sourceResolution() {
        return (Optional<SourceResolution>) sourceResolution;
    }

    /**
     * Determines the media's status, which can be one of the possible values.
     */
    @JsonIgnore
    public Optional<String> status() {
        return status;
    }

    /**
     * Determines the type of MP4 support for the media.   - **none**: Disables MP4 support.   - **capped_4k**: Enables MP4 downloads with resolutions up to 4K.   - **audioOnly**: Provides an MP4 stream containing only the audio.   - **audioOnly,capped_4k**: Enables both MP4 video downloads (up to 4K) and an audio-only stream.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<MediaMp4Support> mp4Support() {
        return (Optional<MediaMp4Support>) mp4Support;
    }

    /**
     * The sourceAccess parameter determines whether the original media file is accessible. Set to true to enable access or false to restrict it
     */
    @JsonIgnore
    public Optional<Boolean> sourceAccess() {
        return sourceAccess;
    }

    /**
     * A collection of Playback ID objects utilized for crafting HLS playback URLs.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<PlaybackId>> playbackIds() {
        return (Optional<List<PlaybackId>>) playbackIds;
    }

    /**
     * A media consists of different media tracks, like video, audio, and subtitle, all combined.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<Track>> tracks() {
        return (Optional<List<Track>>) tracks;
    }

    /**
     * The time span of the media, measured in seconds with a maximum allowable duration of 12 hours per individual media.
     */
    @JsonIgnore
    public Optional<String> duration() {
        return duration;
    }

    /**
     * Frame rate quantifies the speed at which frames are displayed per second. It represents the range of frames available for a specific track. If the frame rate of the input file is indeterminable, it will be indicated by a value of -1.
     */
    @JsonIgnore
    public Optional<String> frameRate() {
        return frameRate;
    }

    /**
     * The aspect ratio of a video is a value that describes the relative shape of a video based on its width and height.
     */
    @JsonIgnore
    public Optional<String> aspectRatio() {
        return aspectRatio;
    }

    /**
     * Time the media was created, defined as a localDateTime (UTC Time).
     */
    @JsonIgnore
    public Optional<OffsetDateTime> createdAt() {
        return createdAt;
    }

    /**
     * Time the media was updated, defined as a localDateTime (UTC Time).
     */
    @JsonIgnore
    public Optional<OffsetDateTime> updatedAt() {
        return updatedAt;
    }

    public final static Builder builder() {
        return new Builder();
    }    

    /**
     * A video thumbnail is a still image that acts as the preview image for your video.
     */
    public Media withThumbnail(String thumbnail) {
        Utils.checkNotNull(thumbnail, "thumbnail");
        this.thumbnail = Optional.ofNullable(thumbnail);
        return this;
    }

    /**
     * A video thumbnail is a still image that acts as the preview image for your video.
     */
    public Media withThumbnail(Optional<String> thumbnail) {
        Utils.checkNotNull(thumbnail, "thumbnail");
        this.thumbnail = thumbnail;
        return this;
    }

    /**
     * When creating the media, FastPix assigns a universally unique identifier with a maximum length of 255 characters.
     */
    public Media withId(String id) {
        Utils.checkNotNull(id, "id");
        this.id = Optional.ofNullable(id);
        return this;
    }

    /**
     * When creating the media, FastPix assigns a universally unique identifier with a maximum length of 255 characters.
     */
    public Media withId(Optional<String> id) {
        Utils.checkNotNull(id, "id");
        this.id = id;
        return this;
    }

    /**
     * A unique identifier is generated by FastPix for the workspace.
     */
    public Media withWorkspaceId(String workspaceId) {
        Utils.checkNotNull(workspaceId, "workspaceId");
        this.workspaceId = Optional.ofNullable(workspaceId);
        return this;
    }

    /**
     * A unique identifier is generated by FastPix for the workspace.
     */
    public Media withWorkspaceId(Optional<String> workspaceId) {
        Utils.checkNotNull(workspaceId, "workspaceId");
        this.workspaceId = workspaceId;
        return this;
    }

    /**
     * You can search for videos with specific key value pairs using metadata, when you tag a video in "key" : "value" pairs. Dynamic Metadata allows you to define a key that allows any value pair. You can have maximum of 255 characters and upto 10 entries are allowed.
     */
    public Media withMetadata(MediaMetadata metadata) {
        Utils.checkNotNull(metadata, "metadata");
        this.metadata = Optional.ofNullable(metadata);
        return this;
    }

    /**
     * You can search for videos with specific key value pairs using metadata, when you tag a video in "key" : "value" pairs. Dynamic Metadata allows you to define a key that allows any value pair. You can have maximum of 255 characters and upto 10 entries are allowed.
     */
    public Media withMetadata(Optional<? extends MediaMetadata> metadata) {
        Utils.checkNotNull(metadata, "metadata");
        this.metadata = metadata;
        return this;
    }

    /**
     * The maximum resolution specified by the user for the media.
     */
    public Media withMaxResolution(MediaMaxResolution maxResolution) {
        Utils.checkNotNull(maxResolution, "maxResolution");
        this.maxResolution = Optional.ofNullable(maxResolution);
        return this;
    }

    /**
     * The maximum resolution specified by the user for the media.
     */
    public Media withMaxResolution(Optional<? extends MediaMaxResolution> maxResolution) {
        Utils.checkNotNull(maxResolution, "maxResolution");
        this.maxResolution = maxResolution;
        return this;
    }

    /**
     * The actual resolution of the uploaded media. This represents the native quality of the source media.
     */
    public Media withSourceResolution(SourceResolution sourceResolution) {
        Utils.checkNotNull(sourceResolution, "sourceResolution");
        this.sourceResolution = Optional.ofNullable(sourceResolution);
        return this;
    }

    /**
     * The actual resolution of the uploaded media. This represents the native quality of the source media.
     */
    public Media withSourceResolution(Optional<? extends SourceResolution> sourceResolution) {
        Utils.checkNotNull(sourceResolution, "sourceResolution");
        this.sourceResolution = sourceResolution;
        return this;
    }

    /**
     * Determines the media's status, which can be one of the possible values.
     */
    public Media withStatus(String status) {
        Utils.checkNotNull(status, "status");
        this.status = Optional.ofNullable(status);
        return this;
    }

    /**
     * Determines the media's status, which can be one of the possible values.
     */
    public Media withStatus(Optional<String> status) {
        Utils.checkNotNull(status, "status");
        this.status = status;
        return this;
    }

    /**
     * Determines the type of MP4 support for the media.   - **none**: Disables MP4 support.   - **capped_4k**: Enables MP4 downloads with resolutions up to 4K.   - **audioOnly**: Provides an MP4 stream containing only the audio.   - **audioOnly,capped_4k**: Enables both MP4 video downloads (up to 4K) and an audio-only stream.
     */
    public Media withMp4Support(MediaMp4Support mp4Support) {
        Utils.checkNotNull(mp4Support, "mp4Support");
        this.mp4Support = Optional.ofNullable(mp4Support);
        return this;
    }

    /**
     * Determines the type of MP4 support for the media.   - **none**: Disables MP4 support.   - **capped_4k**: Enables MP4 downloads with resolutions up to 4K.   - **audioOnly**: Provides an MP4 stream containing only the audio.   - **audioOnly,capped_4k**: Enables both MP4 video downloads (up to 4K) and an audio-only stream.
     */
    public Media withMp4Support(Optional<? extends MediaMp4Support> mp4Support) {
        Utils.checkNotNull(mp4Support, "mp4Support");
        this.mp4Support = mp4Support;
        return this;
    }

    /**
     * The sourceAccess parameter determines whether the original media file is accessible. Set to true to enable access or false to restrict it
     */
    public Media withSourceAccess(boolean sourceAccess) {
        Utils.checkNotNull(sourceAccess, "sourceAccess");
        this.sourceAccess = Optional.ofNullable(sourceAccess);
        return this;
    }

    /**
     * The sourceAccess parameter determines whether the original media file is accessible. Set to true to enable access or false to restrict it
     */
    public Media withSourceAccess(Optional<Boolean> sourceAccess) {
        Utils.checkNotNull(sourceAccess, "sourceAccess");
        this.sourceAccess = sourceAccess;
        return this;
    }

    /**
     * A collection of Playback ID objects utilized for crafting HLS playback URLs.
     */
    public Media withPlaybackIds(List<PlaybackId> playbackIds) {
        Utils.checkNotNull(playbackIds, "playbackIds");
        this.playbackIds = Optional.ofNullable(playbackIds);
        return this;
    }

    /**
     * A collection of Playback ID objects utilized for crafting HLS playback URLs.
     */
    public Media withPlaybackIds(Optional<? extends List<PlaybackId>> playbackIds) {
        Utils.checkNotNull(playbackIds, "playbackIds");
        this.playbackIds = playbackIds;
        return this;
    }

    /**
     * A media consists of different media tracks, like video, audio, and subtitle, all combined.
     */
    public Media withTracks(List<Track> tracks) {
        Utils.checkNotNull(tracks, "tracks");
        this.tracks = Optional.ofNullable(tracks);
        return this;
    }

    /**
     * A media consists of different media tracks, like video, audio, and subtitle, all combined.
     */
    public Media withTracks(Optional<? extends List<Track>> tracks) {
        Utils.checkNotNull(tracks, "tracks");
        this.tracks = tracks;
        return this;
    }

    /**
     * The time span of the media, measured in seconds with a maximum allowable duration of 12 hours per individual media.
     */
    public Media withDuration(String duration) {
        Utils.checkNotNull(duration, "duration");
        this.duration = Optional.ofNullable(duration);
        return this;
    }

    /**
     * The time span of the media, measured in seconds with a maximum allowable duration of 12 hours per individual media.
     */
    public Media withDuration(Optional<String> duration) {
        Utils.checkNotNull(duration, "duration");
        this.duration = duration;
        return this;
    }

    /**
     * Frame rate quantifies the speed at which frames are displayed per second. It represents the range of frames available for a specific track. If the frame rate of the input file is indeterminable, it will be indicated by a value of -1.
     */
    public Media withFrameRate(String frameRate) {
        Utils.checkNotNull(frameRate, "frameRate");
        this.frameRate = Optional.ofNullable(frameRate);
        return this;
    }

    /**
     * Frame rate quantifies the speed at which frames are displayed per second. It represents the range of frames available for a specific track. If the frame rate of the input file is indeterminable, it will be indicated by a value of -1.
     */
    public Media withFrameRate(Optional<String> frameRate) {
        Utils.checkNotNull(frameRate, "frameRate");
        this.frameRate = frameRate;
        return this;
    }

    /**
     * The aspect ratio of a video is a value that describes the relative shape of a video based on its width and height.
     */
    public Media withAspectRatio(String aspectRatio) {
        Utils.checkNotNull(aspectRatio, "aspectRatio");
        this.aspectRatio = Optional.ofNullable(aspectRatio);
        return this;
    }

    /**
     * The aspect ratio of a video is a value that describes the relative shape of a video based on its width and height.
     */
    public Media withAspectRatio(Optional<String> aspectRatio) {
        Utils.checkNotNull(aspectRatio, "aspectRatio");
        this.aspectRatio = aspectRatio;
        return this;
    }

    /**
     * Time the media was created, defined as a localDateTime (UTC Time).
     */
    public Media withCreatedAt(OffsetDateTime createdAt) {
        Utils.checkNotNull(createdAt, "createdAt");
        this.createdAt = Optional.ofNullable(createdAt);
        return this;
    }

    /**
     * Time the media was created, defined as a localDateTime (UTC Time).
     */
    public Media withCreatedAt(Optional<OffsetDateTime> createdAt) {
        Utils.checkNotNull(createdAt, "createdAt");
        this.createdAt = createdAt;
        return this;
    }

    /**
     * Time the media was updated, defined as a localDateTime (UTC Time).
     */
    public Media withUpdatedAt(OffsetDateTime updatedAt) {
        Utils.checkNotNull(updatedAt, "updatedAt");
        this.updatedAt = Optional.ofNullable(updatedAt);
        return this;
    }

    /**
     * Time the media was updated, defined as a localDateTime (UTC Time).
     */
    public Media withUpdatedAt(Optional<OffsetDateTime> updatedAt) {
        Utils.checkNotNull(updatedAt, "updatedAt");
        this.updatedAt = updatedAt;
        return this;
    }

    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        Media other = (Media) o;
        return 
            Objects.deepEquals(this.thumbnail, other.thumbnail) &&
            Objects.deepEquals(this.id, other.id) &&
            Objects.deepEquals(this.workspaceId, other.workspaceId) &&
            Objects.deepEquals(this.metadata, other.metadata) &&
            Objects.deepEquals(this.maxResolution, other.maxResolution) &&
            Objects.deepEquals(this.sourceResolution, other.sourceResolution) &&
            Objects.deepEquals(this.status, other.status) &&
            Objects.deepEquals(this.mp4Support, other.mp4Support) &&
            Objects.deepEquals(this.sourceAccess, other.sourceAccess) &&
            Objects.deepEquals(this.playbackIds, other.playbackIds) &&
            Objects.deepEquals(this.tracks, other.tracks) &&
            Objects.deepEquals(this.duration, other.duration) &&
            Objects.deepEquals(this.frameRate, other.frameRate) &&
            Objects.deepEquals(this.aspectRatio, other.aspectRatio) &&
            Objects.deepEquals(this.createdAt, other.createdAt) &&
            Objects.deepEquals(this.updatedAt, other.updatedAt);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(
            thumbnail,
            id,
            workspaceId,
            metadata,
            maxResolution,
            sourceResolution,
            status,
            mp4Support,
            sourceAccess,
            playbackIds,
            tracks,
            duration,
            frameRate,
            aspectRatio,
            createdAt,
            updatedAt);
    }
    
    @Override
    public String toString() {
        return Utils.toString(Media.class,
                "thumbnail", thumbnail,
                "id", id,
                "workspaceId", workspaceId,
                "metadata", metadata,
                "maxResolution", maxResolution,
                "sourceResolution", sourceResolution,
                "status", status,
                "mp4Support", mp4Support,
                "sourceAccess", sourceAccess,
                "playbackIds", playbackIds,
                "tracks", tracks,
                "duration", duration,
                "frameRate", frameRate,
                "aspectRatio", aspectRatio,
                "createdAt", createdAt,
                "updatedAt", updatedAt);
    }
    
    public final static class Builder {
 
        private Optional<String> thumbnail = Optional.empty();
 
        private Optional<String> id = Optional.empty();
 
        private Optional<String> workspaceId = Optional.empty();
 
        private Optional<? extends MediaMetadata> metadata = Optional.empty();
 
        private Optional<? extends MediaMaxResolution> maxResolution;
 
        private Optional<? extends SourceResolution> sourceResolution;
 
        private Optional<String> status = Optional.empty();
 
        private Optional<? extends MediaMp4Support> mp4Support = Optional.empty();
 
        private Optional<Boolean> sourceAccess = Optional.empty();
 
        private Optional<? extends List<PlaybackId>> playbackIds = Optional.empty();
 
        private Optional<? extends List<Track>> tracks = Optional.empty();
 
        private Optional<String> duration = Optional.empty();
 
        private Optional<String> frameRate = Optional.empty();
 
        private Optional<String> aspectRatio = Optional.empty();
 
        private Optional<OffsetDateTime> createdAt = Optional.empty();
 
        private Optional<OffsetDateTime> updatedAt = Optional.empty();
        
        private Builder() {
          // force use of static builder() method
        }

        /**
         * A video thumbnail is a still image that acts as the preview image for your video.
         */
        public Builder thumbnail(String thumbnail) {
            Utils.checkNotNull(thumbnail, "thumbnail");
            this.thumbnail = Optional.ofNullable(thumbnail);
            return this;
        }

        /**
         * A video thumbnail is a still image that acts as the preview image for your video.
         */
        public Builder thumbnail(Optional<String> thumbnail) {
            Utils.checkNotNull(thumbnail, "thumbnail");
            this.thumbnail = thumbnail;
            return this;
        }

        /**
         * When creating the media, FastPix assigns a universally unique identifier with a maximum length of 255 characters.
         */
        public Builder id(String id) {
            Utils.checkNotNull(id, "id");
            this.id = Optional.ofNullable(id);
            return this;
        }

        /**
         * When creating the media, FastPix assigns a universally unique identifier with a maximum length of 255 characters.
         */
        public Builder id(Optional<String> id) {
            Utils.checkNotNull(id, "id");
            this.id = id;
            return this;
        }

        /**
         * A unique identifier is generated by FastPix for the workspace.
         */
        public Builder workspaceId(String workspaceId) {
            Utils.checkNotNull(workspaceId, "workspaceId");
            this.workspaceId = Optional.ofNullable(workspaceId);
            return this;
        }

        /**
         * A unique identifier is generated by FastPix for the workspace.
         */
        public Builder workspaceId(Optional<String> workspaceId) {
            Utils.checkNotNull(workspaceId, "workspaceId");
            this.workspaceId = workspaceId;
            return this;
        }

        /**
         * You can search for videos with specific key value pairs using metadata, when you tag a video in "key" : "value" pairs. Dynamic Metadata allows you to define a key that allows any value pair. You can have maximum of 255 characters and upto 10 entries are allowed.
         */
        public Builder metadata(MediaMetadata metadata) {
            Utils.checkNotNull(metadata, "metadata");
            this.metadata = Optional.ofNullable(metadata);
            return this;
        }

        /**
         * You can search for videos with specific key value pairs using metadata, when you tag a video in "key" : "value" pairs. Dynamic Metadata allows you to define a key that allows any value pair. You can have maximum of 255 characters and upto 10 entries are allowed.
         */
        public Builder metadata(Optional<? extends MediaMetadata> metadata) {
            Utils.checkNotNull(metadata, "metadata");
            this.metadata = metadata;
            return this;
        }

        /**
         * The maximum resolution specified by the user for the media.
         */
        public Builder maxResolution(MediaMaxResolution maxResolution) {
            Utils.checkNotNull(maxResolution, "maxResolution");
            this.maxResolution = Optional.ofNullable(maxResolution);
            return this;
        }

        /**
         * The maximum resolution specified by the user for the media.
         */
        public Builder maxResolution(Optional<? extends MediaMaxResolution> maxResolution) {
            Utils.checkNotNull(maxResolution, "maxResolution");
            this.maxResolution = maxResolution;
            return this;
        }

        /**
         * The actual resolution of the uploaded media. This represents the native quality of the source media.
         */
        public Builder sourceResolution(SourceResolution sourceResolution) {
            Utils.checkNotNull(sourceResolution, "sourceResolution");
            this.sourceResolution = Optional.ofNullable(sourceResolution);
            return this;
        }

        /**
         * The actual resolution of the uploaded media. This represents the native quality of the source media.
         */
        public Builder sourceResolution(Optional<? extends SourceResolution> sourceResolution) {
            Utils.checkNotNull(sourceResolution, "sourceResolution");
            this.sourceResolution = sourceResolution;
            return this;
        }

        /**
         * Determines the media's status, which can be one of the possible values.
         */
        public Builder status(String status) {
            Utils.checkNotNull(status, "status");
            this.status = Optional.ofNullable(status);
            return this;
        }

        /**
         * Determines the media's status, which can be one of the possible values.
         */
        public Builder status(Optional<String> status) {
            Utils.checkNotNull(status, "status");
            this.status = status;
            return this;
        }

        /**
         * Determines the type of MP4 support for the media.   - **none**: Disables MP4 support.   - **capped_4k**: Enables MP4 downloads with resolutions up to 4K.   - **audioOnly**: Provides an MP4 stream containing only the audio.   - **audioOnly,capped_4k**: Enables both MP4 video downloads (up to 4K) and an audio-only stream.
         */
        public Builder mp4Support(MediaMp4Support mp4Support) {
            Utils.checkNotNull(mp4Support, "mp4Support");
            this.mp4Support = Optional.ofNullable(mp4Support);
            return this;
        }

        /**
         * Determines the type of MP4 support for the media.   - **none**: Disables MP4 support.   - **capped_4k**: Enables MP4 downloads with resolutions up to 4K.   - **audioOnly**: Provides an MP4 stream containing only the audio.   - **audioOnly,capped_4k**: Enables both MP4 video downloads (up to 4K) and an audio-only stream.
         */
        public Builder mp4Support(Optional<? extends MediaMp4Support> mp4Support) {
            Utils.checkNotNull(mp4Support, "mp4Support");
            this.mp4Support = mp4Support;
            return this;
        }

        /**
         * The sourceAccess parameter determines whether the original media file is accessible. Set to true to enable access or false to restrict it
         */
        public Builder sourceAccess(boolean sourceAccess) {
            Utils.checkNotNull(sourceAccess, "sourceAccess");
            this.sourceAccess = Optional.ofNullable(sourceAccess);
            return this;
        }

        /**
         * The sourceAccess parameter determines whether the original media file is accessible. Set to true to enable access or false to restrict it
         */
        public Builder sourceAccess(Optional<Boolean> sourceAccess) {
            Utils.checkNotNull(sourceAccess, "sourceAccess");
            this.sourceAccess = sourceAccess;
            return this;
        }

        /**
         * A collection of Playback ID objects utilized for crafting HLS playback URLs.
         */
        public Builder playbackIds(List<PlaybackId> playbackIds) {
            Utils.checkNotNull(playbackIds, "playbackIds");
            this.playbackIds = Optional.ofNullable(playbackIds);
            return this;
        }

        /**
         * A collection of Playback ID objects utilized for crafting HLS playback URLs.
         */
        public Builder playbackIds(Optional<? extends List<PlaybackId>> playbackIds) {
            Utils.checkNotNull(playbackIds, "playbackIds");
            this.playbackIds = playbackIds;
            return this;
        }

        /**
         * A media consists of different media tracks, like video, audio, and subtitle, all combined.
         */
        public Builder tracks(List<Track> tracks) {
            Utils.checkNotNull(tracks, "tracks");
            this.tracks = Optional.ofNullable(tracks);
            return this;
        }

        /**
         * A media consists of different media tracks, like video, audio, and subtitle, all combined.
         */
        public Builder tracks(Optional<? extends List<Track>> tracks) {
            Utils.checkNotNull(tracks, "tracks");
            this.tracks = tracks;
            return this;
        }

        /**
         * The time span of the media, measured in seconds with a maximum allowable duration of 12 hours per individual media.
         */
        public Builder duration(String duration) {
            Utils.checkNotNull(duration, "duration");
            this.duration = Optional.ofNullable(duration);
            return this;
        }

        /**
         * The time span of the media, measured in seconds with a maximum allowable duration of 12 hours per individual media.
         */
        public Builder duration(Optional<String> duration) {
            Utils.checkNotNull(duration, "duration");
            this.duration = duration;
            return this;
        }

        /**
         * Frame rate quantifies the speed at which frames are displayed per second. It represents the range of frames available for a specific track. If the frame rate of the input file is indeterminable, it will be indicated by a value of -1.
         */
        public Builder frameRate(String frameRate) {
            Utils.checkNotNull(frameRate, "frameRate");
            this.frameRate = Optional.ofNullable(frameRate);
            return this;
        }

        /**
         * Frame rate quantifies the speed at which frames are displayed per second. It represents the range of frames available for a specific track. If the frame rate of the input file is indeterminable, it will be indicated by a value of -1.
         */
        public Builder frameRate(Optional<String> frameRate) {
            Utils.checkNotNull(frameRate, "frameRate");
            this.frameRate = frameRate;
            return this;
        }

        /**
         * The aspect ratio of a video is a value that describes the relative shape of a video based on its width and height.
         */
        public Builder aspectRatio(String aspectRatio) {
            Utils.checkNotNull(aspectRatio, "aspectRatio");
            this.aspectRatio = Optional.ofNullable(aspectRatio);
            return this;
        }

        /**
         * The aspect ratio of a video is a value that describes the relative shape of a video based on its width and height.
         */
        public Builder aspectRatio(Optional<String> aspectRatio) {
            Utils.checkNotNull(aspectRatio, "aspectRatio");
            this.aspectRatio = aspectRatio;
            return this;
        }

        /**
         * Time the media was created, defined as a localDateTime (UTC Time).
         */
        public Builder createdAt(OffsetDateTime createdAt) {
            Utils.checkNotNull(createdAt, "createdAt");
            this.createdAt = Optional.ofNullable(createdAt);
            return this;
        }

        /**
         * Time the media was created, defined as a localDateTime (UTC Time).
         */
        public Builder createdAt(Optional<OffsetDateTime> createdAt) {
            Utils.checkNotNull(createdAt, "createdAt");
            this.createdAt = createdAt;
            return this;
        }

        /**
         * Time the media was updated, defined as a localDateTime (UTC Time).
         */
        public Builder updatedAt(OffsetDateTime updatedAt) {
            Utils.checkNotNull(updatedAt, "updatedAt");
            this.updatedAt = Optional.ofNullable(updatedAt);
            return this;
        }

        /**
         * Time the media was updated, defined as a localDateTime (UTC Time).
         */
        public Builder updatedAt(Optional<OffsetDateTime> updatedAt) {
            Utils.checkNotNull(updatedAt, "updatedAt");
            this.updatedAt = updatedAt;
            return this;
        }
        
        public Media build() {
            if (maxResolution == null) {
                maxResolution = _SINGLETON_VALUE_MaxResolution.value();
            }
            if (sourceResolution == null) {
                sourceResolution = _SINGLETON_VALUE_SourceResolution.value();
            }
            return new Media(
                thumbnail,
                id,
                workspaceId,
                metadata,
                maxResolution,
                sourceResolution,
                status,
                mp4Support,
                sourceAccess,
                playbackIds,
                tracks,
                duration,
                frameRate,
                aspectRatio,
                createdAt,
                updatedAt);
        }

        private static final LazySingletonValue<Optional<? extends MediaMaxResolution>> _SINGLETON_VALUE_MaxResolution =
                new LazySingletonValue<>(
                        "maxResolution",
                        "\"1080p\"",
                        new TypeReference<Optional<? extends MediaMaxResolution>>() {});

        private static final LazySingletonValue<Optional<? extends SourceResolution>> _SINGLETON_VALUE_SourceResolution =
                new LazySingletonValue<>(
                        "sourceResolution",
                        "\"1080p\"",
                        new TypeReference<Optional<? extends SourceResolution>>() {});
    }
}
