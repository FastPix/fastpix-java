/* 
 * This file is auto-generated.
 * Do not edit this file manually.
 * Your changes will be overwritten during the next generation.
 */
package org.openapis.openapi.models.components;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.core.type.TypeReference;
import jakarta.annotation.Nullable;
import java.lang.Boolean;
import java.lang.Override;
import java.lang.String;
import java.time.OffsetDateTime;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import org.openapis.openapi.utils.LazySingletonValue;
import org.openapis.openapi.utils.Utils;
import org.openapitools.jackson.nullable.JsonNullable;


public class SourceAccessMedia {
    /**
     * A video thumbnail is a still image that acts as the preview image for your video.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("thumbnail")
    private JsonNullable<String> thumbnail;

    /**
     * The unique identifier assigned to the media when created. The value must be a valid UUID.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("id")
    private String id;

    /**
     * A unique identifier is generated by FastPix for the workspace.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("workspaceId")
    private String workspaceId;

    /**
     * You can search for videos with specific key value pairs using metadata, when you tag a video in
     * "key" : "value" pairs. Dynamic metadata allows you to define a key that allows any value pair. You
     * can have maximum of 255 characters and upto 10 entries are allowed.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("metadata")
    private JsonNullable<Map<String, String>> metadata;

    /**
     * The quality tier applied to the media.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("mediaQuality")
    private SourceAccessMediaMediaQuality mediaQuality;

    /**
     * The unique identifier of the user who created this media.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("creatorId")
    private String creatorId;

    /**
     * Title of the media file.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("title")
    private JsonNullable<String> title;

    /**
     * The maximum resolution specified by the user for the media.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("maxResolution")
    private SourceAccessMediaMaxResolution maxResolution;

    /**
     * The actual resolution of the uploaded media. This represents the native quality of the source media.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("sourceResolution")
    private SourceAccessMediaSourceResolution sourceResolution;

    /**
     * Determines the media's status, which can be one of the possible values.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("status")
    private SourceAccessMediaStatus status;

    /**
     * The sourceAccess parameter determines whether the original media file is accessible. Set to true to
     * enable access or false to restrict it.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("sourceAccess")
    private JsonNullable<Boolean> sourceAccess;

    /**
     * A collection of Playback ID objects utilized for crafting HLS playback URLs.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("playbackIds")
    private List<PlaybackId> playbackIds;

    /**
     * A media consists of different media tracks, like video, audio, and subtitle, all combined.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("tracks")
    private List<SourceAccessMediaTrack> tracks;

    /**
     * List of generated subtitle tracks associated with the media.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("generatedSubtitles")
    private JsonNullable<List<TracksSubtitles>> generatedSubtitles;

    /**
     * Represents an AI response record containing status and data for AI-generated features like summary,
     * chapters, named entities, or moderation.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("summary")
    private AiSummaryRecord summary;

    /**
     * Represents an AI response record containing status and data for AI-generated features like summary,
     * chapters, named entities, or moderation.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("chapters")
    private AiResponseRecord chapters;

    /**
     * Represents an AI response record containing status and data for AI-generated features like summary,
     * chapters, named entities, or moderation.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("namedEntities")
    private AiResponseRecord namedEntities;

    /**
     * Represents an AI response record containing status and data for AI-generated features like summary,
     * chapters, named entities, or moderation.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("moderation")
    private AiResponseRecord moderation;

    /**
     * Indicates whether the media contains only audio (no video track).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("isAudioOnly")
    private JsonNullable<Boolean> isAudioOnly;

    /**
     * Indicates whether subtitles are available for the media.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("subtitleAvailable")
    private JsonNullable<Boolean> subtitleAvailable;

    /**
     * The length of the media in seconds, with a maximum allowed duration of 12 hours per individual
     * media.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("duration")
    private String duration;

    /**
     * The aspect ratio of a video describes its shape based on the relationship between its width and
     * height.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("aspectRatio")
    private JsonNullable<String> aspectRatio;

    /**
     * Time the media was created, defined as a localDateTime (UTC Time).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("createdAt")
    private OffsetDateTime createdAt;

    /**
     * Time the media was updated, defined as a localDateTime (UTC Time).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("updatedAt")
    private OffsetDateTime updatedAt;

    @JsonCreator
    public SourceAccessMedia(
            @JsonProperty("thumbnail") @Nullable JsonNullable<String> thumbnail,
            @JsonProperty("id") @Nullable String id,
            @JsonProperty("workspaceId") @Nullable String workspaceId,
            @JsonProperty("metadata") @Nullable JsonNullable<Map<String, String>> metadata,
            @JsonProperty("mediaQuality") @Nullable SourceAccessMediaMediaQuality mediaQuality,
            @JsonProperty("creatorId") @Nullable String creatorId,
            @JsonProperty("title") @Nullable JsonNullable<String> title,
            @JsonProperty("maxResolution") @Nullable SourceAccessMediaMaxResolution maxResolution,
            @JsonProperty("sourceResolution") @Nullable SourceAccessMediaSourceResolution sourceResolution,
            @JsonProperty("status") @Nullable SourceAccessMediaStatus status,
            @JsonProperty("sourceAccess") @Nullable JsonNullable<Boolean> sourceAccess,
            @JsonProperty("playbackIds") @Nullable List<PlaybackId> playbackIds,
            @JsonProperty("tracks") @Nullable List<SourceAccessMediaTrack> tracks,
            @JsonProperty("generatedSubtitles") @Nullable JsonNullable<List<TracksSubtitles>> generatedSubtitles,
            @JsonProperty("summary") @Nullable AiSummaryRecord summary,
            @JsonProperty("chapters") @Nullable AiResponseRecord chapters,
            @JsonProperty("namedEntities") @Nullable AiResponseRecord namedEntities,
            @JsonProperty("moderation") @Nullable AiResponseRecord moderation,
            @JsonProperty("isAudioOnly") @Nullable JsonNullable<Boolean> isAudioOnly,
            @JsonProperty("subtitleAvailable") @Nullable JsonNullable<Boolean> subtitleAvailable,
            @JsonProperty("duration") @Nullable String duration,
            @JsonProperty("aspectRatio") @Nullable JsonNullable<String> aspectRatio,
            @JsonProperty("createdAt") @Nullable OffsetDateTime createdAt,
            @JsonProperty("updatedAt") @Nullable OffsetDateTime updatedAt) {
        this.thumbnail = Optional.ofNullable(thumbnail)
            .orElse(JsonNullable.undefined());
        this.id = id;
        this.workspaceId = workspaceId;
        this.metadata = Optional.ofNullable(metadata)
            .orElse(JsonNullable.undefined());
        this.mediaQuality = mediaQuality;
        this.creatorId = creatorId;
        this.title = Optional.ofNullable(title)
            .orElse(JsonNullable.undefined());
        this.maxResolution = Optional.ofNullable(maxResolution)
            .orElse(Builder._SINGLETON_VALUE_MaxResolution.value());
        this.sourceResolution = Optional.ofNullable(sourceResolution)
            .orElse(Builder._SINGLETON_VALUE_SourceResolution.value());
        this.status = status;
        this.sourceAccess = Optional.ofNullable(sourceAccess)
            .orElse(JsonNullable.undefined());
        this.playbackIds = playbackIds;
        this.tracks = tracks;
        this.generatedSubtitles = Optional.ofNullable(generatedSubtitles)
            .orElse(JsonNullable.undefined());
        this.summary = summary;
        this.chapters = chapters;
        this.namedEntities = namedEntities;
        this.moderation = moderation;
        this.isAudioOnly = Optional.ofNullable(isAudioOnly)
            .orElse(JsonNullable.undefined());
        this.subtitleAvailable = Optional.ofNullable(subtitleAvailable)
            .orElse(JsonNullable.undefined());
        this.duration = duration;
        this.aspectRatio = Optional.ofNullable(aspectRatio)
            .orElse(JsonNullable.undefined());
        this.createdAt = createdAt;
        this.updatedAt = updatedAt;
    }
    
    public SourceAccessMedia() {
        this(null, null, null,
            null, null, null,
            null, null, null,
            null, null, null,
            null, null, null,
            null, null, null,
            null, null, null,
            null, null, null);
    }

    /**
     * A video thumbnail is a still image that acts as the preview image for your video.
     */
    public JsonNullable<String> thumbnail() {
        return this.thumbnail;
    }

    /**
     * The unique identifier assigned to the media when created. The value must be a valid UUID.
     */
    public Optional<String> id() {
        return Optional.ofNullable(this.id);
    }

    /**
     * A unique identifier is generated by FastPix for the workspace.
     */
    public Optional<String> workspaceId() {
        return Optional.ofNullable(this.workspaceId);
    }

    /**
     * You can search for videos with specific key value pairs using metadata, when you tag a video in
     * "key" : "value" pairs. Dynamic metadata allows you to define a key that allows any value pair. You
     * can have maximum of 255 characters and upto 10 entries are allowed.
     */
    public JsonNullable<Map<String, String>> metadata() {
        return this.metadata;
    }

    /**
     * The quality tier applied to the media.
     */
    public Optional<SourceAccessMediaMediaQuality> mediaQuality() {
        return Optional.ofNullable(this.mediaQuality);
    }

    /**
     * The unique identifier of the user who created this media.
     */
    public Optional<String> creatorId() {
        return Optional.ofNullable(this.creatorId);
    }

    /**
     * Title of the media file.
     */
    public JsonNullable<String> title() {
        return this.title;
    }

    /**
     * The maximum resolution specified by the user for the media.
     */
    public Optional<SourceAccessMediaMaxResolution> maxResolution() {
        return Optional.ofNullable(this.maxResolution);
    }

    /**
     * The actual resolution of the uploaded media. This represents the native quality of the source media.
     */
    public Optional<SourceAccessMediaSourceResolution> sourceResolution() {
        return Optional.ofNullable(this.sourceResolution);
    }

    /**
     * Determines the media's status, which can be one of the possible values.
     */
    public Optional<SourceAccessMediaStatus> status() {
        return Optional.ofNullable(this.status);
    }

    /**
     * The sourceAccess parameter determines whether the original media file is accessible. Set to true to
     * enable access or false to restrict it.
     */
    public JsonNullable<Boolean> sourceAccess() {
        return this.sourceAccess;
    }

    /**
     * A collection of Playback ID objects utilized for crafting HLS playback URLs.
     */
    public Optional<List<PlaybackId>> playbackIds() {
        return Optional.ofNullable(this.playbackIds);
    }

    /**
     * A media consists of different media tracks, like video, audio, and subtitle, all combined.
     */
    public Optional<List<SourceAccessMediaTrack>> tracks() {
        return Optional.ofNullable(this.tracks);
    }

    /**
     * List of generated subtitle tracks associated with the media.
     */
    public JsonNullable<List<TracksSubtitles>> generatedSubtitles() {
        return this.generatedSubtitles;
    }

    /**
     * Represents an AI response record containing status and data for AI-generated features like summary,
     * chapters, named entities, or moderation.
     */
    public Optional<AiSummaryRecord> summary() {
        return Optional.ofNullable(this.summary);
    }

    /**
     * Represents an AI response record containing status and data for AI-generated features like summary,
     * chapters, named entities, or moderation.
     */
    public Optional<AiResponseRecord> chapters() {
        return Optional.ofNullable(this.chapters);
    }

    /**
     * Represents an AI response record containing status and data for AI-generated features like summary,
     * chapters, named entities, or moderation.
     */
    public Optional<AiResponseRecord> namedEntities() {
        return Optional.ofNullable(this.namedEntities);
    }

    /**
     * Represents an AI response record containing status and data for AI-generated features like summary,
     * chapters, named entities, or moderation.
     */
    public Optional<AiResponseRecord> moderation() {
        return Optional.ofNullable(this.moderation);
    }

    /**
     * Indicates whether the media contains only audio (no video track).
     */
    @JsonIgnore
    public JsonNullable<Boolean> isAudioOnly() {
        return this.isAudioOnly;
    }

    /**
     * Indicates whether subtitles are available for the media.
     */
    public JsonNullable<Boolean> subtitleAvailable() {
        return this.subtitleAvailable;
    }

    /**
     * The length of the media in seconds, with a maximum allowed duration of 12 hours per individual
     * media.
     */
    public Optional<String> duration() {
        return Optional.ofNullable(this.duration);
    }

    /**
     * The aspect ratio of a video describes its shape based on the relationship between its width and
     * height.
     */
    public JsonNullable<String> aspectRatio() {
        return this.aspectRatio;
    }

    /**
     * Time the media was created, defined as a localDateTime (UTC Time).
     */
    public Optional<OffsetDateTime> createdAt() {
        return Optional.ofNullable(this.createdAt);
    }

    /**
     * Time the media was updated, defined as a localDateTime (UTC Time).
     */
    public Optional<OffsetDateTime> updatedAt() {
        return Optional.ofNullable(this.updatedAt);
    }

    public static Builder builder() {
        return new Builder();
    }


    /**
     * A video thumbnail is a still image that acts as the preview image for your video.
     */
    public SourceAccessMedia withThumbnail(@Nullable String thumbnail) {
        this.thumbnail = JsonNullable.of(thumbnail);
        return this;
    }


    /**
     * The unique identifier assigned to the media when created. The value must be a valid UUID.
     */
    public SourceAccessMedia withId(@Nullable String id) {
        this.id = id;
        return this;
    }


    /**
     * A unique identifier is generated by FastPix for the workspace.
     */
    public SourceAccessMedia withWorkspaceId(@Nullable String workspaceId) {
        this.workspaceId = workspaceId;
        return this;
    }


    /**
     * You can search for videos with specific key value pairs using metadata, when you tag a video in
     * "key" : "value" pairs. Dynamic metadata allows you to define a key that allows any value pair. You
     * can have maximum of 255 characters and upto 10 entries are allowed.
     */
    public SourceAccessMedia withMetadata(@Nullable Map<String, String> metadata) {
        this.metadata = JsonNullable.of(metadata);
        return this;
    }


    /**
     * The quality tier applied to the media.
     */
    public SourceAccessMedia withMediaQuality(@Nullable SourceAccessMediaMediaQuality mediaQuality) {
        this.mediaQuality = mediaQuality;
        return this;
    }


    /**
     * The unique identifier of the user who created this media.
     */
    public SourceAccessMedia withCreatorId(@Nullable String creatorId) {
        this.creatorId = creatorId;
        return this;
    }


    /**
     * Title of the media file.
     */
    public SourceAccessMedia withTitle(@Nullable String title) {
        this.title = JsonNullable.of(title);
        return this;
    }


    /**
     * The maximum resolution specified by the user for the media.
     */
    public SourceAccessMedia withMaxResolution(@Nullable SourceAccessMediaMaxResolution maxResolution) {
        this.maxResolution = maxResolution;
        return this;
    }


    /**
     * The actual resolution of the uploaded media. This represents the native quality of the source media.
     */
    public SourceAccessMedia withSourceResolution(@Nullable SourceAccessMediaSourceResolution sourceResolution) {
        this.sourceResolution = sourceResolution;
        return this;
    }


    /**
     * Determines the media's status, which can be one of the possible values.
     */
    public SourceAccessMedia withStatus(@Nullable SourceAccessMediaStatus status) {
        this.status = status;
        return this;
    }


    /**
     * The sourceAccess parameter determines whether the original media file is accessible. Set to true to
     * enable access or false to restrict it.
     */
    public SourceAccessMedia withSourceAccess(@Nullable Boolean sourceAccess) {
        this.sourceAccess = JsonNullable.of(sourceAccess);
        return this;
    }


    /**
     * A collection of Playback ID objects utilized for crafting HLS playback URLs.
     */
    public SourceAccessMedia withPlaybackIds(@Nullable List<PlaybackId> playbackIds) {
        this.playbackIds = playbackIds;
        return this;
    }


    /**
     * A media consists of different media tracks, like video, audio, and subtitle, all combined.
     */
    public SourceAccessMedia withTracks(@Nullable List<SourceAccessMediaTrack> tracks) {
        this.tracks = tracks;
        return this;
    }


    /**
     * List of generated subtitle tracks associated with the media.
     */
    public SourceAccessMedia withGeneratedSubtitles(@Nullable List<TracksSubtitles> generatedSubtitles) {
        this.generatedSubtitles = JsonNullable.of(generatedSubtitles);
        return this;
    }


    /**
     * Represents an AI response record containing status and data for AI-generated features like summary,
     * chapters, named entities, or moderation.
     */
    public SourceAccessMedia withSummary(@Nullable AiSummaryRecord summary) {
        this.summary = summary;
        return this;
    }


    /**
     * Represents an AI response record containing status and data for AI-generated features like summary,
     * chapters, named entities, or moderation.
     */
    public SourceAccessMedia withChapters(@Nullable AiResponseRecord chapters) {
        this.chapters = chapters;
        return this;
    }


    /**
     * Represents an AI response record containing status and data for AI-generated features like summary,
     * chapters, named entities, or moderation.
     */
    public SourceAccessMedia withNamedEntities(@Nullable AiResponseRecord namedEntities) {
        this.namedEntities = namedEntities;
        return this;
    }


    /**
     * Represents an AI response record containing status and data for AI-generated features like summary,
     * chapters, named entities, or moderation.
     */
    public SourceAccessMedia withModeration(@Nullable AiResponseRecord moderation) {
        this.moderation = moderation;
        return this;
    }


    /**
     * Indicates whether the media contains only audio (no video track).
     */
    public SourceAccessMedia withIsAudioOnly(@Nullable Boolean isAudioOnly) {
        this.isAudioOnly = JsonNullable.of(isAudioOnly);
        return this;
    }


    /**
     * Indicates whether subtitles are available for the media.
     */
    public SourceAccessMedia withSubtitleAvailable(@Nullable Boolean subtitleAvailable) {
        this.subtitleAvailable = JsonNullable.of(subtitleAvailable);
        return this;
    }


    /**
     * The length of the media in seconds, with a maximum allowed duration of 12 hours per individual
     * media.
     */
    public SourceAccessMedia withDuration(@Nullable String duration) {
        this.duration = duration;
        return this;
    }


    /**
     * The aspect ratio of a video describes its shape based on the relationship between its width and
     * height.
     */
    public SourceAccessMedia withAspectRatio(@Nullable String aspectRatio) {
        this.aspectRatio = JsonNullable.of(aspectRatio);
        return this;
    }


    /**
     * Time the media was created, defined as a localDateTime (UTC Time).
     */
    public SourceAccessMedia withCreatedAt(@Nullable OffsetDateTime createdAt) {
        this.createdAt = createdAt;
        return this;
    }


    /**
     * Time the media was updated, defined as a localDateTime (UTC Time).
     */
    public SourceAccessMedia withUpdatedAt(@Nullable OffsetDateTime updatedAt) {
        this.updatedAt = updatedAt;
        return this;
    }


    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        SourceAccessMedia other = (SourceAccessMedia) o;
        return 
            Utils.enhancedDeepEquals(this.thumbnail, other.thumbnail) &&
            Utils.enhancedDeepEquals(this.id, other.id) &&
            Utils.enhancedDeepEquals(this.workspaceId, other.workspaceId) &&
            Utils.enhancedDeepEquals(this.metadata, other.metadata) &&
            Utils.enhancedDeepEquals(this.mediaQuality, other.mediaQuality) &&
            Utils.enhancedDeepEquals(this.creatorId, other.creatorId) &&
            Utils.enhancedDeepEquals(this.title, other.title) &&
            Utils.enhancedDeepEquals(this.maxResolution, other.maxResolution) &&
            Utils.enhancedDeepEquals(this.sourceResolution, other.sourceResolution) &&
            Utils.enhancedDeepEquals(this.status, other.status) &&
            Utils.enhancedDeepEquals(this.sourceAccess, other.sourceAccess) &&
            Utils.enhancedDeepEquals(this.playbackIds, other.playbackIds) &&
            Utils.enhancedDeepEquals(this.tracks, other.tracks) &&
            Utils.enhancedDeepEquals(this.generatedSubtitles, other.generatedSubtitles) &&
            Utils.enhancedDeepEquals(this.summary, other.summary) &&
            Utils.enhancedDeepEquals(this.chapters, other.chapters) &&
            Utils.enhancedDeepEquals(this.namedEntities, other.namedEntities) &&
            Utils.enhancedDeepEquals(this.moderation, other.moderation) &&
            Utils.enhancedDeepEquals(this.isAudioOnly, other.isAudioOnly) &&
            Utils.enhancedDeepEquals(this.subtitleAvailable, other.subtitleAvailable) &&
            Utils.enhancedDeepEquals(this.duration, other.duration) &&
            Utils.enhancedDeepEquals(this.aspectRatio, other.aspectRatio) &&
            Utils.enhancedDeepEquals(this.createdAt, other.createdAt) &&
            Utils.enhancedDeepEquals(this.updatedAt, other.updatedAt);
    }
    
    @Override
    public int hashCode() {
        return Utils.enhancedHash(
            thumbnail, id, workspaceId,
            metadata, mediaQuality, creatorId,
            title, maxResolution, sourceResolution,
            status, sourceAccess, playbackIds,
            tracks, generatedSubtitles, summary,
            chapters, namedEntities, moderation,
            isAudioOnly, subtitleAvailable, duration,
            aspectRatio, createdAt, updatedAt);
    }
    
    @Override
    public String toString() {
        return Utils.toString(SourceAccessMedia.class,
                "thumbnail", thumbnail,
                "id", id,
                "workspaceId", workspaceId,
                "metadata", metadata,
                "mediaQuality", mediaQuality,
                "creatorId", creatorId,
                "title", title,
                "maxResolution", maxResolution,
                "sourceResolution", sourceResolution,
                "status", status,
                "sourceAccess", sourceAccess,
                "playbackIds", playbackIds,
                "tracks", tracks,
                "generatedSubtitles", generatedSubtitles,
                "summary", summary,
                "chapters", chapters,
                "namedEntities", namedEntities,
                "moderation", moderation,
                "isAudioOnly", isAudioOnly,
                "subtitleAvailable", subtitleAvailable,
                "duration", duration,
                "aspectRatio", aspectRatio,
                "createdAt", createdAt,
                "updatedAt", updatedAt);
    }

    @SuppressWarnings("UnusedReturnValue")
    public final static class Builder {

        private JsonNullable<String> thumbnail;

        private String id;

        private String workspaceId;

        private JsonNullable<Map<String, String>> metadata;

        private SourceAccessMediaMediaQuality mediaQuality;

        private String creatorId;

        private JsonNullable<String> title;

        private SourceAccessMediaMaxResolution maxResolution;

        private SourceAccessMediaSourceResolution sourceResolution;

        private SourceAccessMediaStatus status;

        private JsonNullable<Boolean> sourceAccess;

        private List<PlaybackId> playbackIds;

        private List<SourceAccessMediaTrack> tracks;

        private JsonNullable<List<TracksSubtitles>> generatedSubtitles;

        private AiSummaryRecord summary;

        private AiResponseRecord chapters;

        private AiResponseRecord namedEntities;

        private AiResponseRecord moderation;

        private JsonNullable<Boolean> isAudioOnly;

        private JsonNullable<Boolean> subtitleAvailable;

        private String duration;

        private JsonNullable<String> aspectRatio;

        private OffsetDateTime createdAt;

        private OffsetDateTime updatedAt;

        private Builder() {
          // force use of static builder() method
        }

        /**
         * A video thumbnail is a still image that acts as the preview image for your video.
         */
        public Builder thumbnail(@Nullable String thumbnail) {
            this.thumbnail = JsonNullable.of(thumbnail);
            return this;
        }

        /**
         * The unique identifier assigned to the media when created. The value must be a valid UUID.
         */
        public Builder id(@Nullable String id) {
            this.id = id;
            return this;
        }

        /**
         * A unique identifier is generated by FastPix for the workspace.
         */
        public Builder workspaceId(@Nullable String workspaceId) {
            this.workspaceId = workspaceId;
            return this;
        }

        /**
         * You can search for videos with specific key value pairs using metadata, when you tag a video in
         * "key" : "value" pairs. Dynamic metadata allows you to define a key that allows any value pair. You
         * can have maximum of 255 characters and upto 10 entries are allowed.
         */
        public Builder metadata(@Nullable Map<String, String> metadata) {
            this.metadata = JsonNullable.of(metadata);
            return this;
        }

        /**
         * The quality tier applied to the media.
         */
        public Builder mediaQuality(@Nullable SourceAccessMediaMediaQuality mediaQuality) {
            this.mediaQuality = mediaQuality;
            return this;
        }

        /**
         * The unique identifier of the user who created this media.
         */
        public Builder creatorId(@Nullable String creatorId) {
            this.creatorId = creatorId;
            return this;
        }

        /**
         * Title of the media file.
         */
        public Builder title(@Nullable String title) {
            this.title = JsonNullable.of(title);
            return this;
        }

        /**
         * The maximum resolution specified by the user for the media.
         */
        public Builder maxResolution(@Nullable SourceAccessMediaMaxResolution maxResolution) {
            this.maxResolution = maxResolution;
            return this;
        }

        /**
         * The actual resolution of the uploaded media. This represents the native quality of the source media.
         */
        public Builder sourceResolution(@Nullable SourceAccessMediaSourceResolution sourceResolution) {
            this.sourceResolution = sourceResolution;
            return this;
        }

        /**
         * Determines the media's status, which can be one of the possible values.
         */
        public Builder status(@Nullable SourceAccessMediaStatus status) {
            this.status = status;
            return this;
        }

        /**
         * The sourceAccess parameter determines whether the original media file is accessible. Set to true to
         * enable access or false to restrict it.
         */
        public Builder sourceAccess(@Nullable Boolean sourceAccess) {
            this.sourceAccess = JsonNullable.of(sourceAccess);
            return this;
        }

        /**
         * A collection of Playback ID objects utilized for crafting HLS playback URLs.
         */
        public Builder playbackIds(@Nullable List<PlaybackId> playbackIds) {
            this.playbackIds = playbackIds;
            return this;
        }

        /**
         * A media consists of different media tracks, like video, audio, and subtitle, all combined.
         */
        public Builder tracks(@Nullable List<SourceAccessMediaTrack> tracks) {
            this.tracks = tracks;
            return this;
        }

        /**
         * List of generated subtitle tracks associated with the media.
         */
        public Builder generatedSubtitles(@Nullable List<TracksSubtitles> generatedSubtitles) {
            this.generatedSubtitles = JsonNullable.of(generatedSubtitles);
            return this;
        }

        /**
         * Represents an AI response record containing status and data for AI-generated features like summary,
         * chapters, named entities, or moderation.
         */
        public Builder summary(@Nullable AiSummaryRecord summary) {
            this.summary = summary;
            return this;
        }

        /**
         * Represents an AI response record containing status and data for AI-generated features like summary,
         * chapters, named entities, or moderation.
         */
        public Builder chapters(@Nullable AiResponseRecord chapters) {
            this.chapters = chapters;
            return this;
        }

        /**
         * Represents an AI response record containing status and data for AI-generated features like summary,
         * chapters, named entities, or moderation.
         */
        public Builder namedEntities(@Nullable AiResponseRecord namedEntities) {
            this.namedEntities = namedEntities;
            return this;
        }

        /**
         * Represents an AI response record containing status and data for AI-generated features like summary,
         * chapters, named entities, or moderation.
         */
        public Builder moderation(@Nullable AiResponseRecord moderation) {
            this.moderation = moderation;
            return this;
        }

        /**
         * Indicates whether the media contains only audio (no video track).
         */
        public Builder isAudioOnly(@Nullable Boolean isAudioOnly) {
            this.isAudioOnly = JsonNullable.of(isAudioOnly);
            return this;
        }

        /**
         * Indicates whether subtitles are available for the media.
         */
        public Builder subtitleAvailable(@Nullable Boolean subtitleAvailable) {
            this.subtitleAvailable = JsonNullable.of(subtitleAvailable);
            return this;
        }

        /**
         * The length of the media in seconds, with a maximum allowed duration of 12 hours per individual
         * media.
         */
        public Builder duration(@Nullable String duration) {
            this.duration = duration;
            return this;
        }

        /**
         * The aspect ratio of a video describes its shape based on the relationship between its width and
         * height.
         */
        public Builder aspectRatio(@Nullable String aspectRatio) {
            this.aspectRatio = JsonNullable.of(aspectRatio);
            return this;
        }

        /**
         * Time the media was created, defined as a localDateTime (UTC Time).
         */
        public Builder createdAt(@Nullable OffsetDateTime createdAt) {
            this.createdAt = createdAt;
            return this;
        }

        /**
         * Time the media was updated, defined as a localDateTime (UTC Time).
         */
        public Builder updatedAt(@Nullable OffsetDateTime updatedAt) {
            this.updatedAt = updatedAt;
            return this;
        }

        public SourceAccessMedia build() {
            return new SourceAccessMedia(
                thumbnail, id, workspaceId,
                metadata, mediaQuality, creatorId,
                title, maxResolution, sourceResolution,
                status, sourceAccess, playbackIds,
                tracks, generatedSubtitles, summary,
                chapters, namedEntities, moderation,
                isAudioOnly, subtitleAvailable, duration,
                aspectRatio, createdAt, updatedAt);
        }


        private static final LazySingletonValue<SourceAccessMediaMaxResolution> _SINGLETON_VALUE_MaxResolution =
                new LazySingletonValue<>(
                        "maxResolution",
                        "\"1080p\"",
                        new TypeReference<SourceAccessMediaMaxResolution>() {});

        private static final LazySingletonValue<SourceAccessMediaSourceResolution> _SINGLETON_VALUE_SourceResolution =
                new LazySingletonValue<>(
                        "sourceResolution",
                        "\"1080p\"",
                        new TypeReference<SourceAccessMediaSourceResolution>() {});
    }
}
