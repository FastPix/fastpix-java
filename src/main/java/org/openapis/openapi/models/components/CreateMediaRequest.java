/* 
 * This file is auto-generated.
 * Do not edit this file manually.
 * Your changes will be overwritten during the next generation.
 */
package org.openapis.openapi.models.components;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.core.type.TypeReference;
import jakarta.annotation.Nonnull;
import jakarta.annotation.Nullable;
import java.lang.Boolean;
import java.lang.Override;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import org.openapis.openapi.utils.LazySingletonValue;
import org.openapis.openapi.utils.Utils;


public class CreateMediaRequest {
    /**
     * Add one input object at a time. For example, first add a **VideoInput** object. If you also need a
     * watermark, click **Add item** again and select **WatermarkInput**.
     * 
     * <p>Repeat this process for **AudioInput** or **SubtitleInput** as needed. For a complete explanation of
     * how media uploads from URL and processing work, refer to the
     * <a href="https://docs.fastpix.io/docs/video-on-demand-overview">FastPix Video on Demand
     * Overview</a>.
     */
    @JsonProperty("inputs")
    private List<Input> inputs;

    /**
     * You can search for videos with specific key value pairs using metadata, when you tag a video in
     * "key" : "value" pairs. Dynamic metadata allows you to define a key that allows any value pair. You
     * can have maximum of 255 characters and upto 10 entries are allowed.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("metadata")
    private Map<String, String> metadata;

    /**
     * UUID of the DRM configuration to be used
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("drmConfigurationId")
    private String drmConfigurationId;

    /**
     * Title of the media file.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("title")
    private String title;

    /**
     * The unique identifier of the user who created this media.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("creatorId")
    private String creatorId;

    /**
     * Generates subtitle files for audio/video files.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("subtitles")
    private Subtitles subtitles;

    /**
     * Determines whether access to the streamed content is kept private or available to all.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("accessPolicy")
    private CreateMediaRequestAccessPolicy accessPolicy;

    /**
     * "capped_4k": Generates an mp4 video file up to 4k resolution "audioOnly": Generates an m4a audio
     * file of the media file "audioOnly,capped_4k": Generates both video and audio media files for offline
     * viewing
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("mp4Support")
    private CreateMediaRequestMp4Support mp4Support;

    /**
     * The sourceAccess parameter determines whether the original media file is accessible. Set to true to
     * enable access or false to restrict it
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("sourceAccess")
    private Boolean sourceAccess;

    /**
     * normalize volume of the audio track. This is available for pre-recorded content only.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("optimizeAudio")
    private Boolean optimizeAudio;

    /**
     * The maximum resolution tier defines the highest quality at which your media is available.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("maxResolution")
    private CreateMediaRequestMaxResolution maxResolution;

    /**
     * The quality tier applied to the media.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("mediaQuality")
    private CreateMediaRequestMediaQuality mediaQuality;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("summary")
    private Summary summary;

    /**
     * Enable or disable the chapters feature for the media. Set to `true` to enable chapters or `false` to
     * disable.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("chapters")
    private Boolean chapters;

    /**
     * Enable or disable named entity extraction. Set to `true` to enable or `false` to disable.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("namedEntities")
    private Boolean namedEntities;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("moderation")
    private Moderation moderation;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("accessRestrictions")
    private CreateMediaRequestAccessRestrictions accessRestrictions;

    @JsonCreator
    public CreateMediaRequest(
            @JsonProperty("inputs") @Nonnull List<Input> inputs,
            @JsonProperty("metadata") @Nullable Map<String, String> metadata,
            @JsonProperty("drmConfigurationId") @Nullable String drmConfigurationId,
            @JsonProperty("title") @Nullable String title,
            @JsonProperty("creatorId") @Nullable String creatorId,
            @JsonProperty("subtitles") @Nullable Subtitles subtitles,
            @JsonProperty("accessPolicy") @Nullable CreateMediaRequestAccessPolicy accessPolicy,
            @JsonProperty("mp4Support") @Nullable CreateMediaRequestMp4Support mp4Support,
            @JsonProperty("sourceAccess") @Nullable Boolean sourceAccess,
            @JsonProperty("optimizeAudio") @Nullable Boolean optimizeAudio,
            @JsonProperty("maxResolution") @Nullable CreateMediaRequestMaxResolution maxResolution,
            @JsonProperty("mediaQuality") @Nullable CreateMediaRequestMediaQuality mediaQuality,
            @JsonProperty("summary") @Nullable Summary summary,
            @JsonProperty("chapters") @Nullable Boolean chapters,
            @JsonProperty("namedEntities") @Nullable Boolean namedEntities,
            @JsonProperty("moderation") @Nullable Moderation moderation,
            @JsonProperty("accessRestrictions") @Nullable CreateMediaRequestAccessRestrictions accessRestrictions) {
        this.inputs = Optional.ofNullable(inputs)
            .orElseThrow(() -> new IllegalArgumentException("inputs cannot be null"));
        this.metadata = metadata;
        this.drmConfigurationId = drmConfigurationId;
        this.title = title;
        this.creatorId = creatorId;
        this.subtitles = subtitles;
        this.accessPolicy = Optional.ofNullable(accessPolicy)
            .orElse(Builder._SINGLETON_VALUE_AccessPolicy.value());
        this.mp4Support = mp4Support;
        this.sourceAccess = sourceAccess;
        this.optimizeAudio = optimizeAudio;
        this.maxResolution = Optional.ofNullable(maxResolution)
            .orElse(Builder._SINGLETON_VALUE_MaxResolution.value());
        this.mediaQuality = Optional.ofNullable(mediaQuality)
            .orElse(Builder._SINGLETON_VALUE_MediaQuality.value());
        this.summary = summary;
        this.chapters = chapters;
        this.namedEntities = namedEntities;
        this.moderation = moderation;
        this.accessRestrictions = accessRestrictions;
    }
    
    public CreateMediaRequest(
            @Nonnull List<Input> inputs) {
        this(inputs, null, null,
            null, null, null,
            null, null, null,
            null, null, null,
            null, null, null,
            null, null);
    }

    /**
     * Add one input object at a time. For example, first add a **VideoInput** object. If you also need a
     * watermark, click **Add item** again and select **WatermarkInput**.
     * 
     * <p>Repeat this process for **AudioInput** or **SubtitleInput** as needed. For a complete explanation of
     * how media uploads from URL and processing work, refer to the
     * <a href="https://docs.fastpix.io/docs/video-on-demand-overview">FastPix Video on Demand
     * Overview</a>.
     */
    public List<Input> inputs() {
        return this.inputs;
    }

    /**
     * You can search for videos with specific key value pairs using metadata, when you tag a video in
     * "key" : "value" pairs. Dynamic metadata allows you to define a key that allows any value pair. You
     * can have maximum of 255 characters and upto 10 entries are allowed.
     */
    public Optional<Map<String, String>> metadata() {
        return Optional.ofNullable(this.metadata);
    }

    /**
     * UUID of the DRM configuration to be used
     */
    public Optional<String> drmConfigurationId() {
        return Optional.ofNullable(this.drmConfigurationId);
    }

    /**
     * Title of the media file.
     */
    public Optional<String> title() {
        return Optional.ofNullable(this.title);
    }

    /**
     * The unique identifier of the user who created this media.
     */
    public Optional<String> creatorId() {
        return Optional.ofNullable(this.creatorId);
    }

    /**
     * Generates subtitle files for audio/video files.
     */
    public Optional<Subtitles> subtitles() {
        return Optional.ofNullable(this.subtitles);
    }

    /**
     * Determines whether access to the streamed content is kept private or available to all.
     */
    public Optional<CreateMediaRequestAccessPolicy> accessPolicy() {
        return Optional.ofNullable(this.accessPolicy);
    }

    /**
     * "capped_4k": Generates an mp4 video file up to 4k resolution "audioOnly": Generates an m4a audio
     * file of the media file "audioOnly,capped_4k": Generates both video and audio media files for offline
     * viewing
     */
    public Optional<CreateMediaRequestMp4Support> mp4Support() {
        return Optional.ofNullable(this.mp4Support);
    }

    /**
     * The sourceAccess parameter determines whether the original media file is accessible. Set to true to
     * enable access or false to restrict it
     */
    public Optional<Boolean> sourceAccess() {
        return Optional.ofNullable(this.sourceAccess);
    }

    /**
     * normalize volume of the audio track. This is available for pre-recorded content only.
     */
    public Optional<Boolean> optimizeAudio() {
        return Optional.ofNullable(this.optimizeAudio);
    }

    /**
     * The maximum resolution tier defines the highest quality at which your media is available.
     */
    public Optional<CreateMediaRequestMaxResolution> maxResolution() {
        return Optional.ofNullable(this.maxResolution);
    }

    /**
     * The quality tier applied to the media.
     */
    public Optional<CreateMediaRequestMediaQuality> mediaQuality() {
        return Optional.ofNullable(this.mediaQuality);
    }

    public Optional<Summary> summary() {
        return Optional.ofNullable(this.summary);
    }

    /**
     * Enable or disable the chapters feature for the media. Set to `true` to enable chapters or `false` to
     * disable.
     */
    public Optional<Boolean> chapters() {
        return Optional.ofNullable(this.chapters);
    }

    /**
     * Enable or disable named entity extraction. Set to `true` to enable or `false` to disable.
     */
    public Optional<Boolean> namedEntities() {
        return Optional.ofNullable(this.namedEntities);
    }

    public Optional<Moderation> moderation() {
        return Optional.ofNullable(this.moderation);
    }

    public Optional<CreateMediaRequestAccessRestrictions> accessRestrictions() {
        return Optional.ofNullable(this.accessRestrictions);
    }

    public static Builder builder() {
        return new Builder();
    }


    /**
     * Add one input object at a time. For example, first add a **VideoInput** object. If you also need a
     * watermark, click **Add item** again and select **WatermarkInput**.
     * 
     * <p>Repeat this process for **AudioInput** or **SubtitleInput** as needed. For a complete explanation of
     * how media uploads from URL and processing work, refer to the
     * <a href="https://docs.fastpix.io/docs/video-on-demand-overview">FastPix Video on Demand
     * Overview</a>.
     */
    public CreateMediaRequest withInputs(@Nonnull List<Input> inputs) {
        this.inputs = Utils.checkNotNull(inputs, "inputs");
        return this;
    }


    /**
     * You can search for videos with specific key value pairs using metadata, when you tag a video in
     * "key" : "value" pairs. Dynamic metadata allows you to define a key that allows any value pair. You
     * can have maximum of 255 characters and upto 10 entries are allowed.
     */
    public CreateMediaRequest withMetadata(@Nullable Map<String, String> metadata) {
        this.metadata = metadata;
        return this;
    }


    /**
     * UUID of the DRM configuration to be used
     */
    public CreateMediaRequest withDrmConfigurationId(@Nullable String drmConfigurationId) {
        this.drmConfigurationId = drmConfigurationId;
        return this;
    }


    /**
     * Title of the media file.
     */
    public CreateMediaRequest withTitle(@Nullable String title) {
        this.title = title;
        return this;
    }


    /**
     * The unique identifier of the user who created this media.
     */
    public CreateMediaRequest withCreatorId(@Nullable String creatorId) {
        this.creatorId = creatorId;
        return this;
    }


    /**
     * Generates subtitle files for audio/video files.
     */
    public CreateMediaRequest withSubtitles(@Nullable Subtitles subtitles) {
        this.subtitles = subtitles;
        return this;
    }


    /**
     * Determines whether access to the streamed content is kept private or available to all.
     */
    public CreateMediaRequest withAccessPolicy(@Nullable CreateMediaRequestAccessPolicy accessPolicy) {
        this.accessPolicy = accessPolicy;
        return this;
    }


    /**
     * "capped_4k": Generates an mp4 video file up to 4k resolution "audioOnly": Generates an m4a audio
     * file of the media file "audioOnly,capped_4k": Generates both video and audio media files for offline
     * viewing
     */
    public CreateMediaRequest withMp4Support(@Nullable CreateMediaRequestMp4Support mp4Support) {
        this.mp4Support = mp4Support;
        return this;
    }


    /**
     * The sourceAccess parameter determines whether the original media file is accessible. Set to true to
     * enable access or false to restrict it
     */
    public CreateMediaRequest withSourceAccess(@Nullable Boolean sourceAccess) {
        this.sourceAccess = sourceAccess;
        return this;
    }


    /**
     * normalize volume of the audio track. This is available for pre-recorded content only.
     */
    public CreateMediaRequest withOptimizeAudio(@Nullable Boolean optimizeAudio) {
        this.optimizeAudio = optimizeAudio;
        return this;
    }


    /**
     * The maximum resolution tier defines the highest quality at which your media is available.
     */
    public CreateMediaRequest withMaxResolution(@Nullable CreateMediaRequestMaxResolution maxResolution) {
        this.maxResolution = maxResolution;
        return this;
    }


    /**
     * The quality tier applied to the media.
     */
    public CreateMediaRequest withMediaQuality(@Nullable CreateMediaRequestMediaQuality mediaQuality) {
        this.mediaQuality = mediaQuality;
        return this;
    }


    public CreateMediaRequest withSummary(@Nullable Summary summary) {
        this.summary = summary;
        return this;
    }


    /**
     * Enable or disable the chapters feature for the media. Set to `true` to enable chapters or `false` to
     * disable.
     */
    public CreateMediaRequest withChapters(@Nullable Boolean chapters) {
        this.chapters = chapters;
        return this;
    }


    /**
     * Enable or disable named entity extraction. Set to `true` to enable or `false` to disable.
     */
    public CreateMediaRequest withNamedEntities(@Nullable Boolean namedEntities) {
        this.namedEntities = namedEntities;
        return this;
    }


    public CreateMediaRequest withModeration(@Nullable Moderation moderation) {
        this.moderation = moderation;
        return this;
    }


    public CreateMediaRequest withAccessRestrictions(@Nullable CreateMediaRequestAccessRestrictions accessRestrictions) {
        this.accessRestrictions = accessRestrictions;
        return this;
    }


    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        CreateMediaRequest other = (CreateMediaRequest) o;
        return 
            Utils.enhancedDeepEquals(this.inputs, other.inputs) &&
            Utils.enhancedDeepEquals(this.metadata, other.metadata) &&
            Utils.enhancedDeepEquals(this.drmConfigurationId, other.drmConfigurationId) &&
            Utils.enhancedDeepEquals(this.title, other.title) &&
            Utils.enhancedDeepEquals(this.creatorId, other.creatorId) &&
            Utils.enhancedDeepEquals(this.subtitles, other.subtitles) &&
            Utils.enhancedDeepEquals(this.accessPolicy, other.accessPolicy) &&
            Utils.enhancedDeepEquals(this.mp4Support, other.mp4Support) &&
            Utils.enhancedDeepEquals(this.sourceAccess, other.sourceAccess) &&
            Utils.enhancedDeepEquals(this.optimizeAudio, other.optimizeAudio) &&
            Utils.enhancedDeepEquals(this.maxResolution, other.maxResolution) &&
            Utils.enhancedDeepEquals(this.mediaQuality, other.mediaQuality) &&
            Utils.enhancedDeepEquals(this.summary, other.summary) &&
            Utils.enhancedDeepEquals(this.chapters, other.chapters) &&
            Utils.enhancedDeepEquals(this.namedEntities, other.namedEntities) &&
            Utils.enhancedDeepEquals(this.moderation, other.moderation) &&
            Utils.enhancedDeepEquals(this.accessRestrictions, other.accessRestrictions);
    }
    
    @Override
    public int hashCode() {
        return Utils.enhancedHash(
            inputs, metadata, drmConfigurationId,
            title, creatorId, subtitles,
            accessPolicy, mp4Support, sourceAccess,
            optimizeAudio, maxResolution, mediaQuality,
            summary, chapters, namedEntities,
            moderation, accessRestrictions);
    }
    
    @Override
    public String toString() {
        return Utils.toString(CreateMediaRequest.class,
                "inputs", inputs,
                "metadata", metadata,
                "drmConfigurationId", drmConfigurationId,
                "title", title,
                "creatorId", creatorId,
                "subtitles", subtitles,
                "accessPolicy", accessPolicy,
                "mp4Support", mp4Support,
                "sourceAccess", sourceAccess,
                "optimizeAudio", optimizeAudio,
                "maxResolution", maxResolution,
                "mediaQuality", mediaQuality,
                "summary", summary,
                "chapters", chapters,
                "namedEntities", namedEntities,
                "moderation", moderation,
                "accessRestrictions", accessRestrictions);
    }

    @SuppressWarnings("UnusedReturnValue")
    public final static class Builder {

        private List<Input> inputs;

        private Map<String, String> metadata;

        private String drmConfigurationId;

        private String title;

        private String creatorId;

        private Subtitles subtitles;

        private CreateMediaRequestAccessPolicy accessPolicy;

        private CreateMediaRequestMp4Support mp4Support;

        private Boolean sourceAccess;

        private Boolean optimizeAudio;

        private CreateMediaRequestMaxResolution maxResolution;

        private CreateMediaRequestMediaQuality mediaQuality;

        private Summary summary;

        private Boolean chapters;

        private Boolean namedEntities;

        private Moderation moderation;

        private CreateMediaRequestAccessRestrictions accessRestrictions;

        private Builder() {
          // force use of static builder() method
        }

        /**
         * Add one input object at a time. For example, first add a **VideoInput** object. If you also need a
         * watermark, click **Add item** again and select **WatermarkInput**.
         * 
         * <p>Repeat this process for **AudioInput** or **SubtitleInput** as needed. For a complete explanation of
         * how media uploads from URL and processing work, refer to the
         * <a href="https://docs.fastpix.io/docs/video-on-demand-overview">FastPix Video on Demand
         * Overview</a>.
         */
        public Builder inputs(@Nonnull List<Input> inputs) {
            this.inputs = Utils.checkNotNull(inputs, "inputs");
            return this;
        }

        /**
         * You can search for videos with specific key value pairs using metadata, when you tag a video in
         * "key" : "value" pairs. Dynamic metadata allows you to define a key that allows any value pair. You
         * can have maximum of 255 characters and upto 10 entries are allowed.
         */
        public Builder metadata(@Nullable Map<String, String> metadata) {
            this.metadata = metadata;
            return this;
        }

        /**
         * UUID of the DRM configuration to be used
         */
        public Builder drmConfigurationId(@Nullable String drmConfigurationId) {
            this.drmConfigurationId = drmConfigurationId;
            return this;
        }

        /**
         * Title of the media file.
         */
        public Builder title(@Nullable String title) {
            this.title = title;
            return this;
        }

        /**
         * The unique identifier of the user who created this media.
         */
        public Builder creatorId(@Nullable String creatorId) {
            this.creatorId = creatorId;
            return this;
        }

        /**
         * Generates subtitle files for audio/video files.
         */
        public Builder subtitles(@Nullable Subtitles subtitles) {
            this.subtitles = subtitles;
            return this;
        }

        /**
         * Determines whether access to the streamed content is kept private or available to all.
         */
        public Builder accessPolicy(@Nullable CreateMediaRequestAccessPolicy accessPolicy) {
            this.accessPolicy = accessPolicy;
            return this;
        }

        /**
         * "capped_4k": Generates an mp4 video file up to 4k resolution "audioOnly": Generates an m4a audio
         * file of the media file "audioOnly,capped_4k": Generates both video and audio media files for offline
         * viewing
         */
        public Builder mp4Support(@Nullable CreateMediaRequestMp4Support mp4Support) {
            this.mp4Support = mp4Support;
            return this;
        }

        /**
         * The sourceAccess parameter determines whether the original media file is accessible. Set to true to
         * enable access or false to restrict it
         */
        public Builder sourceAccess(@Nullable Boolean sourceAccess) {
            this.sourceAccess = sourceAccess;
            return this;
        }

        /**
         * normalize volume of the audio track. This is available for pre-recorded content only.
         */
        public Builder optimizeAudio(@Nullable Boolean optimizeAudio) {
            this.optimizeAudio = optimizeAudio;
            return this;
        }

        /**
         * The maximum resolution tier defines the highest quality at which your media is available.
         */
        public Builder maxResolution(@Nullable CreateMediaRequestMaxResolution maxResolution) {
            this.maxResolution = maxResolution;
            return this;
        }

        /**
         * The quality tier applied to the media.
         */
        public Builder mediaQuality(@Nullable CreateMediaRequestMediaQuality mediaQuality) {
            this.mediaQuality = mediaQuality;
            return this;
        }

        public Builder summary(@Nullable Summary summary) {
            this.summary = summary;
            return this;
        }

        /**
         * Enable or disable the chapters feature for the media. Set to `true` to enable chapters or `false` to
         * disable.
         */
        public Builder chapters(@Nullable Boolean chapters) {
            this.chapters = chapters;
            return this;
        }

        /**
         * Enable or disable named entity extraction. Set to `true` to enable or `false` to disable.
         */
        public Builder namedEntities(@Nullable Boolean namedEntities) {
            this.namedEntities = namedEntities;
            return this;
        }

        public Builder moderation(@Nullable Moderation moderation) {
            this.moderation = moderation;
            return this;
        }

        public Builder accessRestrictions(@Nullable CreateMediaRequestAccessRestrictions accessRestrictions) {
            this.accessRestrictions = accessRestrictions;
            return this;
        }

        public CreateMediaRequest build() {
            return new CreateMediaRequest(
                inputs, metadata, drmConfigurationId,
                title, creatorId, subtitles,
                accessPolicy, mp4Support, sourceAccess,
                optimizeAudio, maxResolution, mediaQuality,
                summary, chapters, namedEntities,
                moderation, accessRestrictions);
        }


        private static final LazySingletonValue<CreateMediaRequestAccessPolicy> _SINGLETON_VALUE_AccessPolicy =
                new LazySingletonValue<>(
                        "accessPolicy",
                        "\"public\"",
                        new TypeReference<CreateMediaRequestAccessPolicy>() {});

        private static final LazySingletonValue<CreateMediaRequestMaxResolution> _SINGLETON_VALUE_MaxResolution =
                new LazySingletonValue<>(
                        "maxResolution",
                        "\"1080p\"",
                        new TypeReference<CreateMediaRequestMaxResolution>() {});

        private static final LazySingletonValue<CreateMediaRequestMediaQuality> _SINGLETON_VALUE_MediaQuality =
                new LazySingletonValue<>(
                        "mediaQuality",
                        "\"standard\"",
                        new TypeReference<CreateMediaRequestMediaQuality>() {});
    }
}
