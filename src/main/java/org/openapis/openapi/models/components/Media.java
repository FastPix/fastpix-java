/* 
 * This file is auto-generated.
 * Do not edit this file manually.
 * Your changes will be overwritten during the next generation.
 */
package org.openapis.openapi.models.components;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.core.type.TypeReference;
import jakarta.annotation.Nullable;
import java.lang.Boolean;
import java.lang.Override;
import java.lang.String;
import java.time.OffsetDateTime;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import org.openapis.openapi.utils.LazySingletonValue;
import org.openapis.openapi.utils.Utils;
import org.openapitools.jackson.nullable.JsonNullable;


public class Media {
    /**
     * A video thumbnail is a still image that acts as the preview image for your video.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("thumbnail")
    private JsonNullable<String> thumbnail;

    /**
     * The unique identifier assigned to the media when created. The value must be a valid UUID.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("id")
    private String id;

    /**
     * A unique identifier is generated by FastPix for the workspace.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("workspaceId")
    private String workspaceId;

    /**
     * You can search for videos with specific key value pairs using metadata, when you tag a video in
     * "key" : "value" pairs. Dynamic metadata allows you to define a key that allows any value pair. You
     * can have maximum of 255 characters and upto 10 entries are allowed.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("metadata")
    private JsonNullable<Map<String, String>> metadata;

    /**
     * The quality tier applied to the media.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("mediaQuality")
    private MediaMediaQuality mediaQuality;

    /**
     * The unique identifier of the user who created this media.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("creatorId")
    private String creatorId;

    /**
     * Title of the media file.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("title")
    private JsonNullable<String> title;

    /**
     * The maximum resolution specified by the user for the media.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("maxResolution")
    private MediaMaxResolution maxResolution;

    /**
     * The actual resolution of the uploaded media. This represents the native quality of the source media.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("sourceResolution")
    private MediaSourceResolution sourceResolution;

    /**
     * Determines the media’s status, which can be one of the possible values.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("status")
    private MediaStatus status;

    /**
     * Determines the type of MP4 support for the media.
     * - **none**: Disables MP4 support.
     * - **capped_4k**: Enables MP4 downloads with resolutions up to 4K.
     * - **audioOnly**: Provides an MP4 stream containing only the audio.
     * - **audioOnly,capped_4k**: Enables both MP4 video downloads (up to 4K) and an audio-only stream.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("mp4Support")
    private MediaMp4Support mp4Support;

    /**
     * The sourceAccess parameter determines whether the original media file is accessible. Set to true to
     * enable access or false to restrict it.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("sourceAccess")
    private JsonNullable<Boolean> sourceAccess;

    /**
     * A collection of Playback ID objects utilized for crafting HLS playback URLs.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("playbackIds")
    private List<PlaybackId> playbackIds;

    /**
     * A media consists of different media tracks, like video, audio, and subtitle, all combined.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("tracks")
    private List<MediaTrack> tracks;

    /**
     * List of generated subtitle tracks associated with the media.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("generatedSubtitles")
    private JsonNullable<List<TracksSubtitles>> generatedSubtitles;

    /**
     * Represents an AI response record containing status and data for AI-generated features like summary,
     * chapters, named entities, or moderation.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("summary")
    private AiSummaryRecord summary;

    /**
     * Represents an AI response record containing status and data for AI-generated features like summary,
     * chapters, named entities, or moderation.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("chapters")
    private AiResponseRecord chapters;

    /**
     * Represents an AI response record containing status and data for AI-generated features like summary,
     * chapters, named entities, or moderation.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("namedEntities")
    private AiResponseRecord namedEntities;

    /**
     * Represents an AI response record containing status and data for AI-generated features like summary,
     * chapters, named entities, or moderation.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("moderation")
    private AiResponseRecord moderation;

    /**
     * Indicates whether the media contains only audio (no video track).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("isAudioOnly")
    private JsonNullable<Boolean> isAudioOnly;

    /**
     * Indicates whether subtitles are available for the media.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("subtitleAvailable")
    private JsonNullable<Boolean> subtitleAvailable;

    /**
     * The length of the media in seconds, with a maximum allowed duration of 12 hours per individual
     * media.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("duration")
    private String duration;

    /**
     * The aspect ratio of a video is a value that describes the relative shape of a video based on its
     * width and height.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("aspectRatio")
    private JsonNullable<String> aspectRatio;

    /**
     * Time the media was created, defined as a localDateTime (UTC Time).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("createdAt")
    private OffsetDateTime createdAt;

    /**
     * Time the media was updated, defined as a localDateTime (UTC Time).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("updatedAt")
    private OffsetDateTime updatedAt;

    @JsonCreator
    public Media(
            @JsonProperty("thumbnail") @Nullable JsonNullable<String> thumbnail,
            @JsonProperty("id") @Nullable String id,
            @JsonProperty("workspaceId") @Nullable String workspaceId,
            @JsonProperty("metadata") @Nullable JsonNullable<Map<String, String>> metadata,
            @JsonProperty("mediaQuality") @Nullable MediaMediaQuality mediaQuality,
            @JsonProperty("creatorId") @Nullable String creatorId,
            @JsonProperty("title") @Nullable JsonNullable<String> title,
            @JsonProperty("maxResolution") @Nullable MediaMaxResolution maxResolution,
            @JsonProperty("sourceResolution") @Nullable MediaSourceResolution sourceResolution,
            @JsonProperty("status") @Nullable MediaStatus status,
            @JsonProperty("mp4Support") @Nullable MediaMp4Support mp4Support,
            @JsonProperty("sourceAccess") @Nullable JsonNullable<Boolean> sourceAccess,
            @JsonProperty("playbackIds") @Nullable List<PlaybackId> playbackIds,
            @JsonProperty("tracks") @Nullable List<MediaTrack> tracks,
            @JsonProperty("generatedSubtitles") @Nullable JsonNullable<List<TracksSubtitles>> generatedSubtitles,
            @JsonProperty("summary") @Nullable AiSummaryRecord summary,
            @JsonProperty("chapters") @Nullable AiResponseRecord chapters,
            @JsonProperty("namedEntities") @Nullable AiResponseRecord namedEntities,
            @JsonProperty("moderation") @Nullable AiResponseRecord moderation,
            @JsonProperty("isAudioOnly") @Nullable JsonNullable<Boolean> isAudioOnly,
            @JsonProperty("subtitleAvailable") @Nullable JsonNullable<Boolean> subtitleAvailable,
            @JsonProperty("duration") @Nullable String duration,
            @JsonProperty("aspectRatio") @Nullable JsonNullable<String> aspectRatio,
            @JsonProperty("createdAt") @Nullable OffsetDateTime createdAt,
            @JsonProperty("updatedAt") @Nullable OffsetDateTime updatedAt) {
        this.thumbnail = Optional.ofNullable(thumbnail)
            .orElse(JsonNullable.undefined());
        this.id = id;
        this.workspaceId = workspaceId;
        this.metadata = Optional.ofNullable(metadata)
            .orElse(JsonNullable.undefined());
        this.mediaQuality = mediaQuality;
        this.creatorId = creatorId;
        this.title = Optional.ofNullable(title)
            .orElse(JsonNullable.undefined());
        this.maxResolution = Optional.ofNullable(maxResolution)
            .orElse(Builder._SINGLETON_VALUE_MaxResolution.value());
        this.sourceResolution = Optional.ofNullable(sourceResolution)
            .orElse(Builder._SINGLETON_VALUE_SourceResolution.value());
        this.status = status;
        this.mp4Support = mp4Support;
        this.sourceAccess = Optional.ofNullable(sourceAccess)
            .orElse(JsonNullable.undefined());
        this.playbackIds = playbackIds;
        this.tracks = tracks;
        this.generatedSubtitles = Optional.ofNullable(generatedSubtitles)
            .orElse(JsonNullable.undefined());
        this.summary = summary;
        this.chapters = chapters;
        this.namedEntities = namedEntities;
        this.moderation = moderation;
        this.isAudioOnly = Optional.ofNullable(isAudioOnly)
            .orElse(JsonNullable.undefined());
        this.subtitleAvailable = Optional.ofNullable(subtitleAvailable)
            .orElse(JsonNullable.undefined());
        this.duration = duration;
        this.aspectRatio = Optional.ofNullable(aspectRatio)
            .orElse(JsonNullable.undefined());
        this.createdAt = createdAt;
        this.updatedAt = updatedAt;
    }
    
    public Media() {
        this(null, null, null,
            null, null, null,
            null, null, null,
            null, null, null,
            null, null, null,
            null, null, null,
            null, null, null,
            null, null, null,
            null);
    }

    /**
     * A video thumbnail is a still image that acts as the preview image for your video.
     */
    public JsonNullable<String> thumbnail() {
        return this.thumbnail;
    }

    /**
     * The unique identifier assigned to the media when created. The value must be a valid UUID.
     */
    public Optional<String> id() {
        return Optional.ofNullable(this.id);
    }

    /**
     * A unique identifier is generated by FastPix for the workspace.
     */
    public Optional<String> workspaceId() {
        return Optional.ofNullable(this.workspaceId);
    }

    /**
     * You can search for videos with specific key value pairs using metadata, when you tag a video in
     * "key" : "value" pairs. Dynamic metadata allows you to define a key that allows any value pair. You
     * can have maximum of 255 characters and upto 10 entries are allowed.
     */
    public JsonNullable<Map<String, String>> metadata() {
        return this.metadata;
    }

    /**
     * The quality tier applied to the media.
     */
    public Optional<MediaMediaQuality> mediaQuality() {
        return Optional.ofNullable(this.mediaQuality);
    }

    /**
     * The unique identifier of the user who created this media.
     */
    public Optional<String> creatorId() {
        return Optional.ofNullable(this.creatorId);
    }

    /**
     * Title of the media file.
     */
    public JsonNullable<String> title() {
        return this.title;
    }

    /**
     * The maximum resolution specified by the user for the media.
     */
    public Optional<MediaMaxResolution> maxResolution() {
        return Optional.ofNullable(this.maxResolution);
    }

    /**
     * The actual resolution of the uploaded media. This represents the native quality of the source media.
     */
    public Optional<MediaSourceResolution> sourceResolution() {
        return Optional.ofNullable(this.sourceResolution);
    }

    /**
     * Determines the media’s status, which can be one of the possible values.
     */
    public Optional<MediaStatus> status() {
        return Optional.ofNullable(this.status);
    }

    /**
     * Determines the type of MP4 support for the media.
     * - **none**: Disables MP4 support.
     * - **capped_4k**: Enables MP4 downloads with resolutions up to 4K.
     * - **audioOnly**: Provides an MP4 stream containing only the audio.
     * - **audioOnly,capped_4k**: Enables both MP4 video downloads (up to 4K) and an audio-only stream.
     */
    public Optional<MediaMp4Support> mp4Support() {
        return Optional.ofNullable(this.mp4Support);
    }

    /**
     * The sourceAccess parameter determines whether the original media file is accessible. Set to true to
     * enable access or false to restrict it.
     */
    public JsonNullable<Boolean> sourceAccess() {
        return this.sourceAccess;
    }

    /**
     * A collection of Playback ID objects utilized for crafting HLS playback URLs.
     */
    public Optional<List<PlaybackId>> playbackIds() {
        return Optional.ofNullable(this.playbackIds);
    }

    /**
     * A media consists of different media tracks, like video, audio, and subtitle, all combined.
     */
    public Optional<List<MediaTrack>> tracks() {
        return Optional.ofNullable(this.tracks);
    }

    /**
     * List of generated subtitle tracks associated with the media.
     */
    public JsonNullable<List<TracksSubtitles>> generatedSubtitles() {
        return this.generatedSubtitles;
    }

    /**
     * Represents an AI response record containing status and data for AI-generated features like summary,
     * chapters, named entities, or moderation.
     */
    public Optional<AiSummaryRecord> summary() {
        return Optional.ofNullable(this.summary);
    }

    /**
     * Represents an AI response record containing status and data for AI-generated features like summary,
     * chapters, named entities, or moderation.
     */
    public Optional<AiResponseRecord> chapters() {
        return Optional.ofNullable(this.chapters);
    }

    /**
     * Represents an AI response record containing status and data for AI-generated features like summary,
     * chapters, named entities, or moderation.
     */
    public Optional<AiResponseRecord> namedEntities() {
        return Optional.ofNullable(this.namedEntities);
    }

    /**
     * Represents an AI response record containing status and data for AI-generated features like summary,
     * chapters, named entities, or moderation.
     */
    public Optional<AiResponseRecord> moderation() {
        return Optional.ofNullable(this.moderation);
    }

    /**
     * Indicates whether the media contains only audio (no video track).
     */
    @JsonIgnore
    public JsonNullable<Boolean> isAudioOnly() {
        return this.isAudioOnly;
    }

    /**
     * Indicates whether subtitles are available for the media.
     */
    public JsonNullable<Boolean> subtitleAvailable() {
        return this.subtitleAvailable;
    }

    /**
     * The length of the media in seconds, with a maximum allowed duration of 12 hours per individual
     * media.
     */
    public Optional<String> duration() {
        return Optional.ofNullable(this.duration);
    }

    /**
     * The aspect ratio of a video is a value that describes the relative shape of a video based on its
     * width and height.
     */
    public JsonNullable<String> aspectRatio() {
        return this.aspectRatio;
    }

    /**
     * Time the media was created, defined as a localDateTime (UTC Time).
     */
    public Optional<OffsetDateTime> createdAt() {
        return Optional.ofNullable(this.createdAt);
    }

    /**
     * Time the media was updated, defined as a localDateTime (UTC Time).
     */
    public Optional<OffsetDateTime> updatedAt() {
        return Optional.ofNullable(this.updatedAt);
    }

    public static Builder builder() {
        return new Builder();
    }


    /**
     * A video thumbnail is a still image that acts as the preview image for your video.
     */
    public Media withThumbnail(@Nullable String thumbnail) {
        this.thumbnail = JsonNullable.of(thumbnail);
        return this;
    }


    /**
     * The unique identifier assigned to the media when created. The value must be a valid UUID.
     */
    public Media withId(@Nullable String id) {
        this.id = id;
        return this;
    }


    /**
     * A unique identifier is generated by FastPix for the workspace.
     */
    public Media withWorkspaceId(@Nullable String workspaceId) {
        this.workspaceId = workspaceId;
        return this;
    }


    /**
     * You can search for videos with specific key value pairs using metadata, when you tag a video in
     * "key" : "value" pairs. Dynamic metadata allows you to define a key that allows any value pair. You
     * can have maximum of 255 characters and upto 10 entries are allowed.
     */
    public Media withMetadata(@Nullable Map<String, String> metadata) {
        this.metadata = JsonNullable.of(metadata);
        return this;
    }


    /**
     * The quality tier applied to the media.
     */
    public Media withMediaQuality(@Nullable MediaMediaQuality mediaQuality) {
        this.mediaQuality = mediaQuality;
        return this;
    }


    /**
     * The unique identifier of the user who created this media.
     */
    public Media withCreatorId(@Nullable String creatorId) {
        this.creatorId = creatorId;
        return this;
    }


    /**
     * Title of the media file.
     */
    public Media withTitle(@Nullable String title) {
        this.title = JsonNullable.of(title);
        return this;
    }


    /**
     * The maximum resolution specified by the user for the media.
     */
    public Media withMaxResolution(@Nullable MediaMaxResolution maxResolution) {
        this.maxResolution = maxResolution;
        return this;
    }


    /**
     * The actual resolution of the uploaded media. This represents the native quality of the source media.
     */
    public Media withSourceResolution(@Nullable MediaSourceResolution sourceResolution) {
        this.sourceResolution = sourceResolution;
        return this;
    }


    /**
     * Determines the media’s status, which can be one of the possible values.
     */
    public Media withStatus(@Nullable MediaStatus status) {
        this.status = status;
        return this;
    }


    /**
     * Determines the type of MP4 support for the media.
     * - **none**: Disables MP4 support.
     * - **capped_4k**: Enables MP4 downloads with resolutions up to 4K.
     * - **audioOnly**: Provides an MP4 stream containing only the audio.
     * - **audioOnly,capped_4k**: Enables both MP4 video downloads (up to 4K) and an audio-only stream.
     */
    public Media withMp4Support(@Nullable MediaMp4Support mp4Support) {
        this.mp4Support = mp4Support;
        return this;
    }


    /**
     * The sourceAccess parameter determines whether the original media file is accessible. Set to true to
     * enable access or false to restrict it.
     */
    public Media withSourceAccess(@Nullable Boolean sourceAccess) {
        this.sourceAccess = JsonNullable.of(sourceAccess);
        return this;
    }


    /**
     * A collection of Playback ID objects utilized for crafting HLS playback URLs.
     */
    public Media withPlaybackIds(@Nullable List<PlaybackId> playbackIds) {
        this.playbackIds = playbackIds;
        return this;
    }


    /**
     * A media consists of different media tracks, like video, audio, and subtitle, all combined.
     */
    public Media withTracks(@Nullable List<MediaTrack> tracks) {
        this.tracks = tracks;
        return this;
    }


    /**
     * List of generated subtitle tracks associated with the media.
     */
    public Media withGeneratedSubtitles(@Nullable List<TracksSubtitles> generatedSubtitles) {
        this.generatedSubtitles = JsonNullable.of(generatedSubtitles);
        return this;
    }


    /**
     * Represents an AI response record containing status and data for AI-generated features like summary,
     * chapters, named entities, or moderation.
     */
    public Media withSummary(@Nullable AiSummaryRecord summary) {
        this.summary = summary;
        return this;
    }


    /**
     * Represents an AI response record containing status and data for AI-generated features like summary,
     * chapters, named entities, or moderation.
     */
    public Media withChapters(@Nullable AiResponseRecord chapters) {
        this.chapters = chapters;
        return this;
    }


    /**
     * Represents an AI response record containing status and data for AI-generated features like summary,
     * chapters, named entities, or moderation.
     */
    public Media withNamedEntities(@Nullable AiResponseRecord namedEntities) {
        this.namedEntities = namedEntities;
        return this;
    }


    /**
     * Represents an AI response record containing status and data for AI-generated features like summary,
     * chapters, named entities, or moderation.
     */
    public Media withModeration(@Nullable AiResponseRecord moderation) {
        this.moderation = moderation;
        return this;
    }


    /**
     * Indicates whether the media contains only audio (no video track).
     */
    public Media withIsAudioOnly(@Nullable Boolean isAudioOnly) {
        this.isAudioOnly = JsonNullable.of(isAudioOnly);
        return this;
    }


    /**
     * Indicates whether subtitles are available for the media.
     */
    public Media withSubtitleAvailable(@Nullable Boolean subtitleAvailable) {
        this.subtitleAvailable = JsonNullable.of(subtitleAvailable);
        return this;
    }


    /**
     * The length of the media in seconds, with a maximum allowed duration of 12 hours per individual
     * media.
     */
    public Media withDuration(@Nullable String duration) {
        this.duration = duration;
        return this;
    }


    /**
     * The aspect ratio of a video is a value that describes the relative shape of a video based on its
     * width and height.
     */
    public Media withAspectRatio(@Nullable String aspectRatio) {
        this.aspectRatio = JsonNullable.of(aspectRatio);
        return this;
    }


    /**
     * Time the media was created, defined as a localDateTime (UTC Time).
     */
    public Media withCreatedAt(@Nullable OffsetDateTime createdAt) {
        this.createdAt = createdAt;
        return this;
    }


    /**
     * Time the media was updated, defined as a localDateTime (UTC Time).
     */
    public Media withUpdatedAt(@Nullable OffsetDateTime updatedAt) {
        this.updatedAt = updatedAt;
        return this;
    }


    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        Media other = (Media) o;
        return 
            Utils.enhancedDeepEquals(this.thumbnail, other.thumbnail) &&
            Utils.enhancedDeepEquals(this.id, other.id) &&
            Utils.enhancedDeepEquals(this.workspaceId, other.workspaceId) &&
            Utils.enhancedDeepEquals(this.metadata, other.metadata) &&
            Utils.enhancedDeepEquals(this.mediaQuality, other.mediaQuality) &&
            Utils.enhancedDeepEquals(this.creatorId, other.creatorId) &&
            Utils.enhancedDeepEquals(this.title, other.title) &&
            Utils.enhancedDeepEquals(this.maxResolution, other.maxResolution) &&
            Utils.enhancedDeepEquals(this.sourceResolution, other.sourceResolution) &&
            Utils.enhancedDeepEquals(this.status, other.status) &&
            Utils.enhancedDeepEquals(this.mp4Support, other.mp4Support) &&
            Utils.enhancedDeepEquals(this.sourceAccess, other.sourceAccess) &&
            Utils.enhancedDeepEquals(this.playbackIds, other.playbackIds) &&
            Utils.enhancedDeepEquals(this.tracks, other.tracks) &&
            Utils.enhancedDeepEquals(this.generatedSubtitles, other.generatedSubtitles) &&
            Utils.enhancedDeepEquals(this.summary, other.summary) &&
            Utils.enhancedDeepEquals(this.chapters, other.chapters) &&
            Utils.enhancedDeepEquals(this.namedEntities, other.namedEntities) &&
            Utils.enhancedDeepEquals(this.moderation, other.moderation) &&
            Utils.enhancedDeepEquals(this.isAudioOnly, other.isAudioOnly) &&
            Utils.enhancedDeepEquals(this.subtitleAvailable, other.subtitleAvailable) &&
            Utils.enhancedDeepEquals(this.duration, other.duration) &&
            Utils.enhancedDeepEquals(this.aspectRatio, other.aspectRatio) &&
            Utils.enhancedDeepEquals(this.createdAt, other.createdAt) &&
            Utils.enhancedDeepEquals(this.updatedAt, other.updatedAt);
    }
    
    @Override
    public int hashCode() {
        return Utils.enhancedHash(
            thumbnail, id, workspaceId,
            metadata, mediaQuality, creatorId,
            title, maxResolution, sourceResolution,
            status, mp4Support, sourceAccess,
            playbackIds, tracks, generatedSubtitles,
            summary, chapters, namedEntities,
            moderation, isAudioOnly, subtitleAvailable,
            duration, aspectRatio, createdAt,
            updatedAt);
    }
    
    @Override
    public String toString() {
        return Utils.toString(Media.class,
                "thumbnail", thumbnail,
                "id", id,
                "workspaceId", workspaceId,
                "metadata", metadata,
                "mediaQuality", mediaQuality,
                "creatorId", creatorId,
                "title", title,
                "maxResolution", maxResolution,
                "sourceResolution", sourceResolution,
                "status", status,
                "mp4Support", mp4Support,
                "sourceAccess", sourceAccess,
                "playbackIds", playbackIds,
                "tracks", tracks,
                "generatedSubtitles", generatedSubtitles,
                "summary", summary,
                "chapters", chapters,
                "namedEntities", namedEntities,
                "moderation", moderation,
                "isAudioOnly", isAudioOnly,
                "subtitleAvailable", subtitleAvailable,
                "duration", duration,
                "aspectRatio", aspectRatio,
                "createdAt", createdAt,
                "updatedAt", updatedAt);
    }

    @SuppressWarnings("UnusedReturnValue")
    public final static class Builder {

        private JsonNullable<String> thumbnail;

        private String id;

        private String workspaceId;

        private JsonNullable<Map<String, String>> metadata;

        private MediaMediaQuality mediaQuality;

        private String creatorId;

        private JsonNullable<String> title;

        private MediaMaxResolution maxResolution;

        private MediaSourceResolution sourceResolution;

        private MediaStatus status;

        private MediaMp4Support mp4Support;

        private JsonNullable<Boolean> sourceAccess;

        private List<PlaybackId> playbackIds;

        private List<MediaTrack> tracks;

        private JsonNullable<List<TracksSubtitles>> generatedSubtitles;

        private AiSummaryRecord summary;

        private AiResponseRecord chapters;

        private AiResponseRecord namedEntities;

        private AiResponseRecord moderation;

        private JsonNullable<Boolean> isAudioOnly;

        private JsonNullable<Boolean> subtitleAvailable;

        private String duration;

        private JsonNullable<String> aspectRatio;

        private OffsetDateTime createdAt;

        private OffsetDateTime updatedAt;

        private Builder() {
          // force use of static builder() method
        }

        /**
         * A video thumbnail is a still image that acts as the preview image for your video.
         */
        public Builder thumbnail(@Nullable String thumbnail) {
            this.thumbnail = JsonNullable.of(thumbnail);
            return this;
        }

        /**
         * The unique identifier assigned to the media when created. The value must be a valid UUID.
         */
        public Builder id(@Nullable String id) {
            this.id = id;
            return this;
        }

        /**
         * A unique identifier is generated by FastPix for the workspace.
         */
        public Builder workspaceId(@Nullable String workspaceId) {
            this.workspaceId = workspaceId;
            return this;
        }

        /**
         * You can search for videos with specific key value pairs using metadata, when you tag a video in
         * "key" : "value" pairs. Dynamic metadata allows you to define a key that allows any value pair. You
         * can have maximum of 255 characters and upto 10 entries are allowed.
         */
        public Builder metadata(@Nullable Map<String, String> metadata) {
            this.metadata = JsonNullable.of(metadata);
            return this;
        }

        /**
         * The quality tier applied to the media.
         */
        public Builder mediaQuality(@Nullable MediaMediaQuality mediaQuality) {
            this.mediaQuality = mediaQuality;
            return this;
        }

        /**
         * The unique identifier of the user who created this media.
         */
        public Builder creatorId(@Nullable String creatorId) {
            this.creatorId = creatorId;
            return this;
        }

        /**
         * Title of the media file.
         */
        public Builder title(@Nullable String title) {
            this.title = JsonNullable.of(title);
            return this;
        }

        /**
         * The maximum resolution specified by the user for the media.
         */
        public Builder maxResolution(@Nullable MediaMaxResolution maxResolution) {
            this.maxResolution = maxResolution;
            return this;
        }

        /**
         * The actual resolution of the uploaded media. This represents the native quality of the source media.
         */
        public Builder sourceResolution(@Nullable MediaSourceResolution sourceResolution) {
            this.sourceResolution = sourceResolution;
            return this;
        }

        /**
         * Determines the media’s status, which can be one of the possible values.
         */
        public Builder status(@Nullable MediaStatus status) {
            this.status = status;
            return this;
        }

        /**
         * Determines the type of MP4 support for the media.
         * - **none**: Disables MP4 support.
         * - **capped_4k**: Enables MP4 downloads with resolutions up to 4K.
         * - **audioOnly**: Provides an MP4 stream containing only the audio.
         * - **audioOnly,capped_4k**: Enables both MP4 video downloads (up to 4K) and an audio-only stream.
         */
        public Builder mp4Support(@Nullable MediaMp4Support mp4Support) {
            this.mp4Support = mp4Support;
            return this;
        }

        /**
         * The sourceAccess parameter determines whether the original media file is accessible. Set to true to
         * enable access or false to restrict it.
         */
        public Builder sourceAccess(@Nullable Boolean sourceAccess) {
            this.sourceAccess = JsonNullable.of(sourceAccess);
            return this;
        }

        /**
         * A collection of Playback ID objects utilized for crafting HLS playback URLs.
         */
        public Builder playbackIds(@Nullable List<PlaybackId> playbackIds) {
            this.playbackIds = playbackIds;
            return this;
        }

        /**
         * A media consists of different media tracks, like video, audio, and subtitle, all combined.
         */
        public Builder tracks(@Nullable List<MediaTrack> tracks) {
            this.tracks = tracks;
            return this;
        }

        /**
         * List of generated subtitle tracks associated with the media.
         */
        public Builder generatedSubtitles(@Nullable List<TracksSubtitles> generatedSubtitles) {
            this.generatedSubtitles = JsonNullable.of(generatedSubtitles);
            return this;
        }

        /**
         * Represents an AI response record containing status and data for AI-generated features like summary,
         * chapters, named entities, or moderation.
         */
        public Builder summary(@Nullable AiSummaryRecord summary) {
            this.summary = summary;
            return this;
        }

        /**
         * Represents an AI response record containing status and data for AI-generated features like summary,
         * chapters, named entities, or moderation.
         */
        public Builder chapters(@Nullable AiResponseRecord chapters) {
            this.chapters = chapters;
            return this;
        }

        /**
         * Represents an AI response record containing status and data for AI-generated features like summary,
         * chapters, named entities, or moderation.
         */
        public Builder namedEntities(@Nullable AiResponseRecord namedEntities) {
            this.namedEntities = namedEntities;
            return this;
        }

        /**
         * Represents an AI response record containing status and data for AI-generated features like summary,
         * chapters, named entities, or moderation.
         */
        public Builder moderation(@Nullable AiResponseRecord moderation) {
            this.moderation = moderation;
            return this;
        }

        /**
         * Indicates whether the media contains only audio (no video track).
         */
        public Builder isAudioOnly(@Nullable Boolean isAudioOnly) {
            this.isAudioOnly = JsonNullable.of(isAudioOnly);
            return this;
        }

        /**
         * Indicates whether subtitles are available for the media.
         */
        public Builder subtitleAvailable(@Nullable Boolean subtitleAvailable) {
            this.subtitleAvailable = JsonNullable.of(subtitleAvailable);
            return this;
        }

        /**
         * The length of the media in seconds, with a maximum allowed duration of 12 hours per individual
         * media.
         */
        public Builder duration(@Nullable String duration) {
            this.duration = duration;
            return this;
        }

        /**
         * The aspect ratio of a video is a value that describes the relative shape of a video based on its
         * width and height.
         */
        public Builder aspectRatio(@Nullable String aspectRatio) {
            this.aspectRatio = JsonNullable.of(aspectRatio);
            return this;
        }

        /**
         * Time the media was created, defined as a localDateTime (UTC Time).
         */
        public Builder createdAt(@Nullable OffsetDateTime createdAt) {
            this.createdAt = createdAt;
            return this;
        }

        /**
         * Time the media was updated, defined as a localDateTime (UTC Time).
         */
        public Builder updatedAt(@Nullable OffsetDateTime updatedAt) {
            this.updatedAt = updatedAt;
            return this;
        }

        public Media build() {
            return new Media(
                thumbnail, id, workspaceId,
                metadata, mediaQuality, creatorId,
                title, maxResolution, sourceResolution,
                status, mp4Support, sourceAccess,
                playbackIds, tracks, generatedSubtitles,
                summary, chapters, namedEntities,
                moderation, isAudioOnly, subtitleAvailable,
                duration, aspectRatio, createdAt,
                updatedAt);
        }


        private static final LazySingletonValue<MediaMaxResolution> _SINGLETON_VALUE_MaxResolution =
                new LazySingletonValue<>(
                        "maxResolution",
                        "\"1080p\"",
                        new TypeReference<MediaMaxResolution>() {});

        private static final LazySingletonValue<MediaSourceResolution> _SINGLETON_VALUE_SourceResolution =
                new LazySingletonValue<>(
                        "sourceResolution",
                        "\"1080p\"",
                        new TypeReference<MediaSourceResolution>() {});
    }
}
