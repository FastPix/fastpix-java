/* 
 * This file is auto-generated.
 * Do not edit this file manually.
 * Your changes will be overwritten during the next generation.
 */
package org.openapis.openapi;

import static org.openapis.openapi.operations.Operations.RequestlessOperation;
import static org.openapis.openapi.operations.Operations.RequestOperation;

import jakarta.annotation.Nonnull;
import jakarta.annotation.Nullable;
import java.lang.Long;
import java.lang.String;
import org.openapis.openapi.models.operations.CreateSigningKeyRequestBuilder;
import org.openapis.openapi.models.operations.CreateSigningKeyResponse;
import org.openapis.openapi.models.operations.DeleteSigningKeyRequest;
import org.openapis.openapi.models.operations.DeleteSigningKeyRequestBuilder;
import org.openapis.openapi.models.operations.DeleteSigningKeyResponse;
import org.openapis.openapi.models.operations.GetSigningKeyByIdRequest;
import org.openapis.openapi.models.operations.GetSigningKeyByIdRequestBuilder;
import org.openapis.openapi.models.operations.GetSigningKeyByIdResponse;
import org.openapis.openapi.models.operations.ListSigningKeysRequest;
import org.openapis.openapi.models.operations.ListSigningKeysRequestBuilder;
import org.openapis.openapi.models.operations.ListSigningKeysResponse;
import org.openapis.openapi.operations.CreateSigningKey;
import org.openapis.openapi.operations.DeleteSigningKey;
import org.openapis.openapi.operations.GetSigningKeyById;
import org.openapis.openapi.operations.ListSigningKeys;
import org.openapis.openapi.utils.Headers;
import org.openapis.openapi.utils.Options;


public class SigningKeys {
    private static final Headers _headers = Headers.EMPTY;
    private final SDKConfiguration sdkConfiguration;
    private final AsyncSigningKeys asyncSDK;

    SigningKeys(SDKConfiguration sdkConfiguration) {
        this.sdkConfiguration = sdkConfiguration;
        this.asyncSDK = new AsyncSigningKeys(this, sdkConfiguration);
    }

    /**
     * Switches to the async SDK.
     * 
     * @return The async SDK
     */
    public AsyncSigningKeys async() {
        return asyncSDK;
    }

    /**
     * Create a signing key
     * 
     * <p>This endpoint allows you to create a new signing key pair for FastPix. When you call this endpoint,
     * the API generates a 2048-bit RSA key pair. The privateKey is returned in the response, encoded in
     * Base64 format.
     * 
     * <p>You also receive a unique key ID to reference the key in future operations. FastPix securely stores
     * the public key to validate signed tokens.
     * 
     * <p>&lt;h4&gt;Instructions&lt;/h4&gt;
     * 
     * <p>**Private key handling:** The privateKey you receive is encoded in Base64. To use it, decode the
     * value using Base64 decoding. Make sure to store this private key securely, as it is required for
     * signing tokens.
     * 
     * <p>**Key-ID:** The ID is used to reference this specific key pair in future API requests or
     * configurations.
     * 
     * <p>After the key pair is generated, the developer must securely store the private key because FastPix
     * does not save it. The public key is used by FastPix to verify signed tokens and ensure that the
     * client interacting with the system is legitimate.
     * 
     * <p>&lt;h4&gt;Use case scenario&lt;/h4&gt;
     * 
     * <p>**Use case:** A developer building a video subscription service wants to ensure that only authorized
     * users can access premium content. By generating a signing key, the developer can issue signed JSON
     * Web Tokens (JWTs) to authenticate and authorize users. These tokens can be validated by FastPix
     * using the stored public key.
     * 
     * <p>**Detailed example:**  You are building a video-on-demand platform that restricts access based on
     * user subscriptions. To ensure only subscribed users can stream content, you generate a signing key
     * using this API. Each time a user logs in, you create a JWT signed with the private key.
     * 
     * <p>When the user attempts to play a video, FastPix uses the public key to verify the token and confirms
     * that the user is authorized.<br/>
     * Related guide: <a href="https://docs.fastpix.io/docs/secure-playback-with-jwts">Create and use
     * signing keys</a>
     * 
     * @return The call builder
     */
    public CreateSigningKeyRequestBuilder create() {
        return new CreateSigningKeyRequestBuilder(sdkConfiguration);
    }

    /**
     * Create a signing key
     * 
     * <p>This endpoint allows you to create a new signing key pair for FastPix. When you call this endpoint,
     * the API generates a 2048-bit RSA key pair. The privateKey is returned in the response, encoded in
     * Base64 format.
     * 
     * <p>You also receive a unique key ID to reference the key in future operations. FastPix securely stores
     * the public key to validate signed tokens.
     * 
     * <p>&lt;h4&gt;Instructions&lt;/h4&gt;
     * 
     * <p>**Private key handling:** The privateKey you receive is encoded in Base64. To use it, decode the
     * value using Base64 decoding. Make sure to store this private key securely, as it is required for
     * signing tokens.
     * 
     * <p>**Key-ID:** The ID is used to reference this specific key pair in future API requests or
     * configurations.
     * 
     * <p>After the key pair is generated, the developer must securely store the private key because FastPix
     * does not save it. The public key is used by FastPix to verify signed tokens and ensure that the
     * client interacting with the system is legitimate.
     * 
     * <p>&lt;h4&gt;Use case scenario&lt;/h4&gt;
     * 
     * <p>**Use case:** A developer building a video subscription service wants to ensure that only authorized
     * users can access premium content. By generating a signing key, the developer can issue signed JSON
     * Web Tokens (JWTs) to authenticate and authorize users. These tokens can be validated by FastPix
     * using the stored public key.
     * 
     * <p>**Detailed example:**  You are building a video-on-demand platform that restricts access based on
     * user subscriptions. To ensure only subscribed users can stream content, you generate a signing key
     * using this API. Each time a user logs in, you create a JWT signed with the private key.
     * 
     * <p>When the user attempts to play a video, FastPix uses the public key to verify the token and confirms
     * that the user is authorized.<br/>
     * Related guide: <a href="https://docs.fastpix.io/docs/secure-playback-with-jwts">Create and use
     * signing keys</a>
     * 
     * @return The response from the API call
     * @throws RuntimeException subclass if the API call fails
     */
    public CreateSigningKeyResponse createDirect() {
        return create(null);
    }

    /**
     * Create a signing key
     * 
     * <p>This endpoint allows you to create a new signing key pair for FastPix. When you call this endpoint,
     * the API generates a 2048-bit RSA key pair. The privateKey is returned in the response, encoded in
     * Base64 format.
     * 
     * <p>You also receive a unique key ID to reference the key in future operations. FastPix securely stores
     * the public key to validate signed tokens.
     * 
     * <p>&lt;h4&gt;Instructions&lt;/h4&gt;
     * 
     * <p>**Private key handling:** The privateKey you receive is encoded in Base64. To use it, decode the
     * value using Base64 decoding. Make sure to store this private key securely, as it is required for
     * signing tokens.
     * 
     * <p>**Key-ID:** The ID is used to reference this specific key pair in future API requests or
     * configurations.
     * 
     * <p>After the key pair is generated, the developer must securely store the private key because FastPix
     * does not save it. The public key is used by FastPix to verify signed tokens and ensure that the
     * client interacting with the system is legitimate.
     * 
     * <p>&lt;h4&gt;Use case scenario&lt;/h4&gt;
     * 
     * <p>**Use case:** A developer building a video subscription service wants to ensure that only authorized
     * users can access premium content. By generating a signing key, the developer can issue signed JSON
     * Web Tokens (JWTs) to authenticate and authorize users. These tokens can be validated by FastPix
     * using the stored public key.
     * 
     * <p>**Detailed example:**  You are building a video-on-demand platform that restricts access based on
     * user subscriptions. To ensure only subscribed users can stream content, you generate a signing key
     * using this API. Each time a user logs in, you create a JWT signed with the private key.
     * 
     * <p>When the user attempts to play a video, FastPix uses the public key to verify the token and confirms
     * that the user is authorized.<br/>
     * Related guide: <a href="https://docs.fastpix.io/docs/secure-playback-with-jwts">Create and use
     * signing keys</a>
     * 
     * @param options additional options
     * @return The response from the API call
     * @throws RuntimeException subclass if the API call fails
     */
    public CreateSigningKeyResponse create(@Nullable Options options) {
        RequestlessOperation<CreateSigningKeyResponse> operation
            = new CreateSigningKey.Sync(sdkConfiguration, options, _headers);
        return operation.handleResponse(operation.doRequest());
    }

    /**
     * Get list of signing key
     * 
     * <p>This endpoint returns a list of all the signing keys associated with an organization in FastPix.
     * Each key entry in the response includes metadata such as the key id, creation date, and workspace
     * details. This helps you manage multiple keys, track their usage, and identify which keys are valid
     * for signing API requests.
     * 
     * <p>&lt;h4&gt;How it works&lt;/h4&gt;
     * 
     * <p>The API returns the list in a paginated format, allowing you to audit and track all keys used for
     * your application. Regularly reviewing this list is essential for ensuring that old or compromised
     * keys are promptly revoked and that new keys are properly integrated into workflows.
     * 
     * <p>&lt;h4&gt;Use case scenario&lt;/h4&gt;
     * 
     * <p>**Use case:** A security-conscious development team wants to ensure they follow a key rotation
     * policy, rotating signing keys every few months. By retrieving the list of signing keys, they can
     * identify which keys are still in use and which ones need to be rotated.
     * 
     * <p>**Detailed example:**  You manage a multi-region video platform where teams in different regions use
     * their own signing keys. To comply with your organization’s security policies, you regularly review
     * the list of signing keys to verify which ones are still active. You notice that some keys haven’t
     * been used for several months.
     * 
     * <p>Based on their creation dates, you decide to rotate those keys.
     * 
     * @return The call builder
     */
    public ListSigningKeysRequestBuilder list() {
        return new ListSigningKeysRequestBuilder(sdkConfiguration);
    }

    /**
     * Get list of signing key
     * 
     * <p>This endpoint returns a list of all the signing keys associated with an organization in FastPix.
     * Each key entry in the response includes metadata such as the key id, creation date, and workspace
     * details. This helps you manage multiple keys, track their usage, and identify which keys are valid
     * for signing API requests.
     * 
     * <p>&lt;h4&gt;How it works&lt;/h4&gt;
     * 
     * <p>The API returns the list in a paginated format, allowing you to audit and track all keys used for
     * your application. Regularly reviewing this list is essential for ensuring that old or compromised
     * keys are promptly revoked and that new keys are properly integrated into workflows.
     * 
     * <p>&lt;h4&gt;Use case scenario&lt;/h4&gt;
     * 
     * <p>**Use case:** A security-conscious development team wants to ensure they follow a key rotation
     * policy, rotating signing keys every few months. By retrieving the list of signing keys, they can
     * identify which keys are still in use and which ones need to be rotated.
     * 
     * <p>**Detailed example:**  You manage a multi-region video platform where teams in different regions use
     * their own signing keys. To comply with your organization’s security policies, you regularly review
     * the list of signing keys to verify which ones are still active. You notice that some keys haven’t
     * been used for several months.
     * 
     * <p>Based on their creation dates, you decide to rotate those keys.
     * 
     * @return The response from the API call
     * @throws RuntimeException subclass if the API call fails
     */
    public ListSigningKeysResponse listDirect() {
        return list(null, null, null);
    }

    /**
     * Get list of signing key
     * 
     * <p>This endpoint returns a list of all the signing keys associated with an organization in FastPix.
     * Each key entry in the response includes metadata such as the key id, creation date, and workspace
     * details. This helps you manage multiple keys, track their usage, and identify which keys are valid
     * for signing API requests.
     * 
     * <p>&lt;h4&gt;How it works&lt;/h4&gt;
     * 
     * <p>The API returns the list in a paginated format, allowing you to audit and track all keys used for
     * your application. Regularly reviewing this list is essential for ensuring that old or compromised
     * keys are promptly revoked and that new keys are properly integrated into workflows.
     * 
     * <p>&lt;h4&gt;Use case scenario&lt;/h4&gt;
     * 
     * <p>**Use case:** A security-conscious development team wants to ensure they follow a key rotation
     * policy, rotating signing keys every few months. By retrieving the list of signing keys, they can
     * identify which keys are still in use and which ones need to be rotated.
     * 
     * <p>**Detailed example:**  You manage a multi-region video platform where teams in different regions use
     * their own signing keys. To comply with your organization’s security policies, you regularly review
     * the list of signing keys to verify which ones are still active. You notice that some keys haven’t
     * been used for several months.
     * 
     * <p>Based on their creation dates, you decide to rotate those keys.
     * 
     * @param limit Limit specifies the maximum number of items to display per page.
     * @param offset It is used for pagination, indicating the starting point for fetching data.  
     * @param options additional options
     * @return The response from the API call
     * @throws RuntimeException subclass if the API call fails
     */
    public ListSigningKeysResponse list(
            @Nullable Long limit, @Nullable Long offset,
            @Nullable Options options) {
        ListSigningKeysRequest request = new ListSigningKeysRequest(limit, offset);
        RequestOperation<ListSigningKeysRequest, ListSigningKeysResponse> operation
              = new ListSigningKeys.Sync(sdkConfiguration, options, _headers);
        return operation.handleResponse(operation.doRequest(request));
    }

    /**
     * Delete a signing key
     * 
     * <p>This endpoint allows you to delete an existing signing key, and the action is permanent. After a key
     * is deleted, any signatures or tokens generated with that key become invalid immediately. This means
     * you can no longer use the key to sign JSON Web Tokens (JWTs) or authenticate API requests.
     * &lt;h4&gt;Usage&lt;/h4&gt;
     * To delete a signing key, provide the unique key ID that you obtained when creating the key. This key
     * id serves as the identifier for the specific signing key you want to remove from your account.
     * 
     * <p>&lt;h4&gt;How it works&lt;/h4&gt;
     * 
     * <p>When you specify the keyId, the API removes the signing key from the system. After the key is
     * deleted, any API requests or tokens that rely on it fail. This action is useful when a key is
     * compromised or when rotating keys as part of security policies.
     * 
     * <p>&lt;h4&gt;Use case scenario&lt;/h4&gt;
     * 
     * <p>**Use case:** A key used by an outdated application version has been compromised, or a developer
     * accidentally leaked it. To prevent unauthorized access, the developer deletes the signing key,
     * revoking its ability to sign requests immediately.
     * 
     * <p>**Detailed example:**  Suppose you have a signing key used for a specific version of your mobile
     * app, and you discover that the key has been compromised due to a security breach. To mitigate the
     * issue, you delete the key to invalidate any tokens generated using it. As soon as the key is
     * deleted, users on the compromised version of the app can no longer make valid requests, thus
     * preventing further exploitation.
     * 
     * @return The call builder
     */
    public DeleteSigningKeyRequestBuilder delete() {
        return new DeleteSigningKeyRequestBuilder(sdkConfiguration);
    }

    /**
     * Delete a signing key
     * 
     * <p>This endpoint allows you to delete an existing signing key, and the action is permanent. After a key
     * is deleted, any signatures or tokens generated with that key become invalid immediately. This means
     * you can no longer use the key to sign JSON Web Tokens (JWTs) or authenticate API requests.
     * &lt;h4&gt;Usage&lt;/h4&gt;
     * To delete a signing key, provide the unique key ID that you obtained when creating the key. This key
     * id serves as the identifier for the specific signing key you want to remove from your account.
     * 
     * <p>&lt;h4&gt;How it works&lt;/h4&gt;
     * 
     * <p>When you specify the keyId, the API removes the signing key from the system. After the key is
     * deleted, any API requests or tokens that rely on it fail. This action is useful when a key is
     * compromised or when rotating keys as part of security policies.
     * 
     * <p>&lt;h4&gt;Use case scenario&lt;/h4&gt;
     * 
     * <p>**Use case:** A key used by an outdated application version has been compromised, or a developer
     * accidentally leaked it. To prevent unauthorized access, the developer deletes the signing key,
     * revoking its ability to sign requests immediately.
     * 
     * <p>**Detailed example:**  Suppose you have a signing key used for a specific version of your mobile
     * app, and you discover that the key has been compromised due to a security breach. To mitigate the
     * issue, you delete the key to invalidate any tokens generated using it. As soon as the key is
     * deleted, users on the compromised version of the app can no longer make valid requests, thus
     * preventing further exploitation.
     * 
     * @param signingKeyId When creating the signing key, FastPix assigns a universally unique identifier with a maximum length of 255 characters.
     * @return The response from the API call
     * @throws RuntimeException subclass if the API call fails
     */
    public DeleteSigningKeyResponse delete(@Nonnull String signingKeyId) {
        return delete(signingKeyId, null);
    }

    /**
     * Delete a signing key
     * 
     * <p>This endpoint allows you to delete an existing signing key, and the action is permanent. After a key
     * is deleted, any signatures or tokens generated with that key become invalid immediately. This means
     * you can no longer use the key to sign JSON Web Tokens (JWTs) or authenticate API requests.
     * &lt;h4&gt;Usage&lt;/h4&gt;
     * To delete a signing key, provide the unique key ID that you obtained when creating the key. This key
     * id serves as the identifier for the specific signing key you want to remove from your account.
     * 
     * <p>&lt;h4&gt;How it works&lt;/h4&gt;
     * 
     * <p>When you specify the keyId, the API removes the signing key from the system. After the key is
     * deleted, any API requests or tokens that rely on it fail. This action is useful when a key is
     * compromised or when rotating keys as part of security policies.
     * 
     * <p>&lt;h4&gt;Use case scenario&lt;/h4&gt;
     * 
     * <p>**Use case:** A key used by an outdated application version has been compromised, or a developer
     * accidentally leaked it. To prevent unauthorized access, the developer deletes the signing key,
     * revoking its ability to sign requests immediately.
     * 
     * <p>**Detailed example:**  Suppose you have a signing key used for a specific version of your mobile
     * app, and you discover that the key has been compromised due to a security breach. To mitigate the
     * issue, you delete the key to invalidate any tokens generated using it. As soon as the key is
     * deleted, users on the compromised version of the app can no longer make valid requests, thus
     * preventing further exploitation.
     * 
     * @param signingKeyId When creating the signing key, FastPix assigns a universally unique identifier with a maximum length of 255 characters.
     * @param options additional options
     * @return The response from the API call
     * @throws RuntimeException subclass if the API call fails
     */
    public DeleteSigningKeyResponse delete(@Nonnull String signingKeyId, @Nullable Options options) {
        DeleteSigningKeyRequest request = new DeleteSigningKeyRequest(signingKeyId);
        RequestOperation<DeleteSigningKeyRequest, DeleteSigningKeyResponse> operation
              = new DeleteSigningKey.Sync(sdkConfiguration, options, _headers);
        return operation.handleResponse(operation.doRequest(request));
    }

    /**
     * Get signing key by ID
     * 
     * <p>This endpoint allows you to retrieve detailed information about a specific signing key using its
     * unique key id. While the private key is not returned for security reasons, You can view the key’s
     * creation date, status, and other associated metadata. This endpoint also returns the workspaceId and
     * publicKey in the response.
     * 
     * <p>&lt;h4&gt;Usage: Generating a JWT token&lt;/h4&gt;
     * 
     * <p>In the response, the API returns the workspaceId and publicKey associated with the signing key. With
     * the publicKey and the privateKey obtained from the "Create a Signing Key" endpoint, you can generate
     * a JSON Web Token (JWT) using the RS256 algorithm. This token can be utilized for accessing private
     * media assets, GIFs, thumbnails, and spritesheets.
     * 
     * <p>&lt;h4&gt;Payload:&lt;/h4&gt;
     * 
     * <p>```
     * {
     * "kid": "359302ee-2446-4afe-9348-8b4656b9ddb1",
     * "aud": "media:6cee6f85-9334-4a51-9ce3-e0241d94ceef",
     * "iss": "fastpix.io",
     * "sub": "",
     * "iat": 1706703204,
     * "exp": 1735626783
     * 
     * <p>}
     * ```
     * 
     * <p>* **kid:** The key ID of the signing key.
     * * **aud:** The audience for which the token is intended, enter the playbackId here.
     * * **iss:**  The issuer of the token (for example, "fastpix.io ").
     * * **sub:** The subject of the token, typically representing the user or entity the token is issued
     * for. In this case, use the workspaceId fetched from the "Get Signing Key by ID" endpoint.
     * * **groups:** An array of groups the subject belongs to (for example, ["user"]).
     * * **iat:** The issued-at timestamp, indicating when the token was created.
     * * **exp:** The expiration timestamp, indicating when the token will no longer be valid.
     * 
     * <p>&lt;h4&gt;Use case scenario&lt;/h4&gt;
     * 
     * <p>**Use case:** A developer is unsure about the status of a signing key they created months ago and
     * wants to verify whether it's still in use or has expired.
     * 
     * <p>**Detailed example:**  You’re working on a streaming platform and realize you haven’t checked the
     * status of a signing key that was used for playback access several months ago. By fetching the key
     * details using its ID, you can confirm whether it’s still active, when it was created, and if it’s
     * nearing expiration. This allows you to plan a rotation or deactivation if needed.
     * 
     * @return The call builder
     */
    public GetSigningKeyByIdRequestBuilder getById() {
        return new GetSigningKeyByIdRequestBuilder(sdkConfiguration);
    }

    /**
     * Get signing key by ID
     * 
     * <p>This endpoint allows you to retrieve detailed information about a specific signing key using its
     * unique key id. While the private key is not returned for security reasons, You can view the key’s
     * creation date, status, and other associated metadata. This endpoint also returns the workspaceId and
     * publicKey in the response.
     * 
     * <p>&lt;h4&gt;Usage: Generating a JWT token&lt;/h4&gt;
     * 
     * <p>In the response, the API returns the workspaceId and publicKey associated with the signing key. With
     * the publicKey and the privateKey obtained from the "Create a Signing Key" endpoint, you can generate
     * a JSON Web Token (JWT) using the RS256 algorithm. This token can be utilized for accessing private
     * media assets, GIFs, thumbnails, and spritesheets.
     * 
     * <p>&lt;h4&gt;Payload:&lt;/h4&gt;
     * 
     * <p>```
     * {
     * "kid": "359302ee-2446-4afe-9348-8b4656b9ddb1",
     * "aud": "media:6cee6f85-9334-4a51-9ce3-e0241d94ceef",
     * "iss": "fastpix.io",
     * "sub": "",
     * "iat": 1706703204,
     * "exp": 1735626783
     * 
     * <p>}
     * ```
     * 
     * <p>* **kid:** The key ID of the signing key.
     * * **aud:** The audience for which the token is intended, enter the playbackId here.
     * * **iss:**  The issuer of the token (for example, "fastpix.io ").
     * * **sub:** The subject of the token, typically representing the user or entity the token is issued
     * for. In this case, use the workspaceId fetched from the "Get Signing Key by ID" endpoint.
     * * **groups:** An array of groups the subject belongs to (for example, ["user"]).
     * * **iat:** The issued-at timestamp, indicating when the token was created.
     * * **exp:** The expiration timestamp, indicating when the token will no longer be valid.
     * 
     * <p>&lt;h4&gt;Use case scenario&lt;/h4&gt;
     * 
     * <p>**Use case:** A developer is unsure about the status of a signing key they created months ago and
     * wants to verify whether it's still in use or has expired.
     * 
     * <p>**Detailed example:**  You’re working on a streaming platform and realize you haven’t checked the
     * status of a signing key that was used for playback access several months ago. By fetching the key
     * details using its ID, you can confirm whether it’s still active, when it was created, and if it’s
     * nearing expiration. This allows you to plan a rotation or deactivation if needed.
     * 
     * @param signingKeyId When creating the signing key, FastPix assigns a universally unique identifier with a maximum length of 255 characters. 
     * @return The response from the API call
     * @throws RuntimeException subclass if the API call fails
     */
    public GetSigningKeyByIdResponse getById(@Nonnull String signingKeyId) {
        return getById(signingKeyId, null);
    }

    /**
     * Get signing key by ID
     * 
     * <p>This endpoint allows you to retrieve detailed information about a specific signing key using its
     * unique key id. While the private key is not returned for security reasons, You can view the key’s
     * creation date, status, and other associated metadata. This endpoint also returns the workspaceId and
     * publicKey in the response.
     * 
     * <p>&lt;h4&gt;Usage: Generating a JWT token&lt;/h4&gt;
     * 
     * <p>In the response, the API returns the workspaceId and publicKey associated with the signing key. With
     * the publicKey and the privateKey obtained from the "Create a Signing Key" endpoint, you can generate
     * a JSON Web Token (JWT) using the RS256 algorithm. This token can be utilized for accessing private
     * media assets, GIFs, thumbnails, and spritesheets.
     * 
     * <p>&lt;h4&gt;Payload:&lt;/h4&gt;
     * 
     * <p>```
     * {
     * "kid": "359302ee-2446-4afe-9348-8b4656b9ddb1",
     * "aud": "media:6cee6f85-9334-4a51-9ce3-e0241d94ceef",
     * "iss": "fastpix.io",
     * "sub": "",
     * "iat": 1706703204,
     * "exp": 1735626783
     * 
     * <p>}
     * ```
     * 
     * <p>* **kid:** The key ID of the signing key.
     * * **aud:** The audience for which the token is intended, enter the playbackId here.
     * * **iss:**  The issuer of the token (for example, "fastpix.io ").
     * * **sub:** The subject of the token, typically representing the user or entity the token is issued
     * for. In this case, use the workspaceId fetched from the "Get Signing Key by ID" endpoint.
     * * **groups:** An array of groups the subject belongs to (for example, ["user"]).
     * * **iat:** The issued-at timestamp, indicating when the token was created.
     * * **exp:** The expiration timestamp, indicating when the token will no longer be valid.
     * 
     * <p>&lt;h4&gt;Use case scenario&lt;/h4&gt;
     * 
     * <p>**Use case:** A developer is unsure about the status of a signing key they created months ago and
     * wants to verify whether it's still in use or has expired.
     * 
     * <p>**Detailed example:**  You’re working on a streaming platform and realize you haven’t checked the
     * status of a signing key that was used for playback access several months ago. By fetching the key
     * details using its ID, you can confirm whether it’s still active, when it was created, and if it’s
     * nearing expiration. This allows you to plan a rotation or deactivation if needed.
     * 
     * @param signingKeyId When creating the signing key, FastPix assigns a universally unique identifier with a maximum length of 255 characters. 
     * @param options additional options
     * @return The response from the API call
     * @throws RuntimeException subclass if the API call fails
     */
    public GetSigningKeyByIdResponse getById(@Nonnull String signingKeyId, @Nullable Options options) {
        GetSigningKeyByIdRequest request = new GetSigningKeyByIdRequest(signingKeyId);
        RequestOperation<GetSigningKeyByIdRequest, GetSigningKeyByIdResponse> operation
              = new GetSigningKeyById.Sync(sdkConfiguration, options, _headers);
        return operation.handleResponse(operation.doRequest(request));
    }

}
